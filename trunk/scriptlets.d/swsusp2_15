# -*- sh -*-
# vim:ft=sh:ts=8:sw=4:noet

SWSUSP_INTERFACE_VERSION_MIN=15
SWSUSP_INTERFACE_VERSION_MAX=15

# Detect the new /proc root.
if [ -d "/proc/swsusp/" ] ; then
    SWSUSP_ROOT="/proc/swsusp"
else
    SWSUSP_ROOT="/proc/software_suspend"
fi

SWSUSP_DEFAULT_ALL_SETTINGS_FILE="$SWSUSP_D/swsusp2-all-settings.conf"

AddConfigHandler Swsusp2ConfigEnabler
AddOptionHandler Swsusp2OptionHandler

AddConfigHelp "UseSwsusp2 <boolean>" "Enable/disable the use of Software Suspend 2 to suspend."

AddConfigHelp "Reboot <boolean> (requires UseSwsusp2 on)" "Controls whether or not Software Suspend 2 should reboot after suspending. Setting this to yes will force a reboot. Setting this to no will force shutting down. Omitting this option will leave rebooting behaviour unchanged."
AddShortOption "r::"
AddLongOption "reboot::"
AddOptionHelp "-r[0|1], --reboot[=<0|1>] (requires UseSwsusp2 on)" "If 0 is specified, disables rebooting after suspend, regardless of the Reboot option in the configuration file. If 1 or omitted, will force a reboot after suspending."

AddConfigHelp "EnableEscape <boolean> (requires UseSwsusp2 on)" "If specified, allows (or disallows) the use of the escape key to abort a suspend. If this line is not specified, the Escape key's behaviour is unchanged."

AddConfigHelp "DefaultConsoleLevel <N> (requires UseSwsusp2 on)" "If specified, sets the default console level. 0 gives a progress bar. 1 gives a progress bar with numbers. 2 or higher give increasing amounts of debugging. If this line is not specified, the default console level is unchanged."

AddConfigHelp "ImageSizeLimit nocache|<NN> (requires UseSwsusp2 on)" "If specified, sets an upper limit on the size of the suspend image written (in megabytes). If set to \"nocache\", caches and buffers will not be saved - resulting in a faster suspend and resume at the possible expense of system responsiveness immediately after resuming. If set to 0, no limit is imposed. If this line is not specified, the existing image size limit is unchanged."

AddConfigHelp "AsyncIOLimit <N> (requires UseSwsusp2 on)" "Deprecated since 2.1.5.11 (hence won't do anything if set). Limit the number of I/O operations that Software Suspend 2 will have queued at once. Lowering this value has resolved hangs when reading or writing caches for some people. Try values like 64, 32 and 8."

AddConfigHelp "Swsusp2AllSettings <params> (requires UseSwsusp2 on)" "If specified, sets all of the settings for Software Suspend 2 at once. The parameter should be the contents of $SWSUSP_ROOT/all_settings after you have set your desired settings manually."

AddConfigHelp "Swsusp2AllSettingsFile <filename> (requires UseSwsusp2 on)" "If specified, sets all of the settings for Software Suspend 2 and all its plugins at once, from the given file. The parameter should be the path to a file containing the result of \"cat $SWSUSP_ROOT/all_settings > <filename>\"after you have set your desired settings manually."

AddConfigHelp "SuspendDevice <device> (requires UseSwsusp2 on)" "If specified, sets the suspend device by writing to the resume2 entry in $SWSUSP_ROOT. This does not automatically set the resuming device - you will need to make sure your bootloader or initrd script does this."

AddConfigHelp "FilewriterLocation <filename> (requires UseSwsusp2 on)" "This option sets up the given filename to act as a destination file for writing the suspend image to, and verifies that it can act as a valid destination. It is only relevant if you are using the filewriter plugin for Software Suspend."

AddConfigHelp "LoadSuspendModules <module name> [...] (requires UseSwsusp2 on)" "Loads the given modules before even detecting Software Suspend. This may be required when Software Suspend is compiled as modules that need to be loaded prior to suspending."
AddConfigHelp "UnloadSuspendModulesAfterResume <boolean> (requires UseSwsusp2 on)" "If yes, will unload the Software Suspend modules mentioned above after resuming."

AddConfigHelp "PowerdownMethod <3|4|5> (requires UseSwsusp2 on)" "Allows you to choose what Software Suspend 2 should do after writing its image to disk. This only works if you have ACPI enabled in your kernel. 3/4/5 correspond to the ACPI states S3 (suspend-to-RAM), S4 (suspend-to-disk), and S5 (power off). Choosing 3 will request your machine to enter the S3 Suspend-to-RAM state if it is supported - this allows you drastically cut the resume time waiting for your BIOS but still consumes power whilst hibernated (though the image is not lost should power run out). Choosing 4 will cause your machine to enter an S4 sleep state which may also reduce the resume time without using any power whilst hibernated. Choosing 5 will cause your machine to switch off after suspending (traditional method)."

AddConfigHelp "ProcSetting <entry name> <value> (requires UseSwsusp2 on)" "Sets the value of $SWSUSP_ROOT/<entry_name> to <value> upon suspending. You can use this setting to set parameters that can't be configured anywhere else in this script. This is executed after all other settings have been set."

AddShortOption "n"
AddLongOption "no-suspend"
AddOptionHelp "-n, --no-suspend (requires UseSwsusp2 on)" "Disables actually suspending the system. This is useful for testing the suspend script itself."

AddLongOption "save-settings::"
AddOptionHelp "--save-settings [filename] (requires UseSwsusp2 on)" "Saves all the current settings for Software Suspend 2 into a file (default: $SWSUSP_DEFAULT_ALL_SETTINGS_FILE)"

AddLongOption "bug-report"
AddOptionHelp "--bug-report (requires UseSwsusp2 on)" "Gathers a bunch of information about your machine and writes it to standard output. Please attach this information along with any bug reports to the Software Suspend mailing list."

Swsusp2ConfigEnabler() {
    [ "$1" != "useswsusp2" ] && return 1
    BoolIsOn "$1" "$2" || return 0
    [ -n "$USING_SWSUSP2" ] && return 0
    AddConfigHandler Swsusp2ConfigOptions
    AddSuspendHook 10 EnsureSwsusp2Capable
    AddSuspendHook 97 ChangeToSwsuspVT
    AddSuspendHook 99 DoSwsusp2
    AddResumeHook 97 ChangeFromSwsuspVT
    USING_SWSUSP2=1
    return 0
}

Swsusp2OptionHandler() {
    # Don't parse options if we're not being used.
    [ -z "$USING_SWSUSP2" ] && return 1

    case $1 in
	-r|--reboot)
	    if [ -z "$2" ] ; then
		# Cmd-line options will always override config file
		OPT_REBOOT=1
	    else
		BoolIsOn "-r" "$2" && OPT_REBOOT=1 || OPT_REBOOT=0
	    fi
	    ;;
	-n|--no-suspend)
	    SWSUSP2_NO_SUSPEND=1
	    ;;
	--save-settings)
	    if [ -n "$2" ] ; then
		SWSUSP2_SAVE_SETTINGS_FILE="$2"
	    else
		SWSUSP2_SAVE_SETTINGS_FILE="$SWSUSP_DEFAULT_ALL_SETTINGS_FILE"
	    fi
	    AddSuspendHook 00 Swsusp2SaveSettings
	    ;;
	--bug-report)
	    SWSUSP2_BUG_REPORT=1
	    ;;
	*)
	    return 1
    esac
    return 0
}

Swsusp2ConfigOptions() {
    case $1 in
	reboot)
	    if [ -z "$OPT_REBOOT" ] ; then
		BoolIsOn "$1" "$2" && OPT_REBOOT=1 || OPT_REBOOT=0
	    fi
	    ;;
	enableescape)
	    if [ -z "$OPT_ESCAPE" ] ; then
		BoolIsOn "$1" "$2" && OPT_ESCAPE=1 || OPT_ESCAPE=0
	    fi
	    ;;
	defaultconsolelevel)
	    OPT_CONSOLELEVEL=$2
	    ;;
	imagesizelimit)
	    SWSUSP_IMAGE_SIZE_LIMIT=$2
	    ;;
	asynciolimit)
	    SWSUSP_ASYNC_IO_LIMIT=$2
	    ;;
	swsusp2allsettings)
	    SWSUSP_ALL_SETTINGS=$2
	    ;;
	swsusp2allsettingsfile)
	    SWSUSP_ALL_SETTINGS_FILE=$2
	    if ! [ -r "$SWSUSP_ALL_SETTINGS_FILE" ] ; then
		echo "$EXE: Cannot read all_settings file $SWSUSP_ALL_SETTINGS_FILE"
		return 0
	    fi
	    ;;
	suspenddevice)
	    SWSUSP_RESUME2=$2
	    ;;
	filewriterlocation)
	    SWSUSP_FILEWRITER_LOC=$2
	    AddSuspendHook 06 Swsusp2SetupFilewriter
	    ;;
	loadsuspendmodules)
	    AddSuspendHook 05 Swsusp2LoadModules
	    shift
	    SWSUSP_LOAD_MODULES=$@
	    ;;
	unloadsuspendmodulesafterresume)
	    BoolIsOn "$1" "$2" || return 0
	    AddResumeHook 05 Swsusp2UnloadModules
	    ;;
	powerdownmethod)
	    case $2 in
		[3-5])
		    SWSUSP_POWERDOWN_METHOD=$2
		    ;;
		*)
		    echo "$EXE: Invalid value for $1 ($2). Must be 3 4 or 5."
		    return 0
		    ;;
	    esac
	    ;;
	procsetting)
	    if [ -z "$OPT_DRY_RUN" ] ; then
		if [ -z "$SWSUSP_EXTRA_PROC_SETTINGS" ] ; then
		    SWSUSP_EXTRA_PROC_SETTINGS=`mktemp /tmp/tmp.hibernate.XXXXXX`
		    cat <<EOT > $SWSUSP_EXTRA_PROC_SETTINGS
# Temporary file for hibernate script.
# If you're reading this then it's probably safe to delete.

EOT
		    AddResumeHook 00 RemoveSwsuspProcCruft
		fi
		shift
		FILE="$1"
		shift
		echo "echo \"$*\" > $SWSUSP_ROOT/$FILE" >> $SWSUSP_EXTRA_PROC_SETTINGS
	    fi
	    ;;
	*)
	    return 1
    esac
    if [ -z "$SWSUSP2_HOOKED" ] ; then
	AddSuspendHook 98 Swsusp2ConfigSet
	SWSUSP2_HOOKED=1
    fi
    return 0
}

Swsusp2SaveSettings() {
    if ! [ -r "$SWSUSP_ROOT/all_settings" ] ; then
	echo "$EXE: Could not read $SWSUSP_ROOT/all_settings."
    elif ! cat "$SWSUSP_ROOT/all_settings" > $SWSUSP2_SAVE_SETTINGS_FILE ; then
	echo "$EXE: Could not save settings. cat failed."
    else
	echo "$EXE: Settings saved to $SWSUSP2_SAVE_SETTINGS_FILE."
    fi
    return 3
}

RemoveSwsuspProcCruft() {
    [ -f "$SWSUSP_EXTRA_PROC_SETTINGS" ] && rm -f $SWSUSP_EXTRA_PROC_SETTINGS
    return 0
}

Swsusp2ConfigSet() {
    if [ "x$SWSUSP_IMAGE_SIZE_LIMIT" = "xnocache" ] ; then
	local field val units result
	local total=0 cached=0 buffers=0 free=0
	while read field val units ; do
	    [ "x$field" = "xMemTotal:" ] && total=$val
	    [ "x$field" = "xMemFree:" ] && free=$val
	    [ "x$field" = "xBuffers:" ] && buffers=$val
	    [ "x$field" = "xCached:" ] && cached=$val
	done < /proc/meminfo
	result=$((($total-$cached-$buffers-$free+10240)/1024))
	vecho 2 "Setting image size limit to $result."
	echo $result > $SWSUSP_ROOT/image_size_limit
    else
	[ -n "$SWSUSP_IMAGE_SIZE_LIMIT" ] && echo $SWSUSP_IMAGE_SIZE_LIMIT > $SWSUSP_ROOT/image_size_limit
    fi

    [ -n "$OPT_REBOOT" ] && [ -f "$SWSUSP_ROOT/reboot" ] && \
	echo $OPT_REBOOT > $SWSUSP_ROOT/reboot

    [ -n "$OPT_ESCAPE" ] && [ -f $SWSUSP_ROOT/enable_escape ] && \
	echo $OPT_ESCAPE > $SWSUSP_ROOT/enable_escape

    [ -n "$OPT_CONSOLELEVEL" ] && [ -f $SWSUSP_ROOT/default_console_level ] && \
	echo $OPT_CONSOLELEVEL > $SWSUSP_ROOT/default_console_level

    [ -n "$SWSUSP_ASYNC_IO_LIMIT" ] && [ -f $SWSUSP_ROOT/async_io_limit ] && \
    	echo $SWSUSP_ASYNC_IO_LIMIT > $SWSUSP_ROOT/async_io_limit

    [ -n "$SWSUSP_ALL_SETTINGS" ] && [ -f $SWSUSP_ROOT/all_settings ] && \
    	echo $SWSUSP_ALL_SETTINGS > $SWSUSP_ROOT/all_settings

    [ -n "$SWSUSP_ALL_SETTINGS_FILE" ] && [ -f $SWSUSP_ROOT/all_settings ] && \
	[ -f "$SWSUSP_ALL_SETTINGS_FILE" ] && \
    	cat $SWSUSP_ALL_SETTINGS_FILE > $SWSUSP_ROOT/all_settings

    [ -n "$SWSUSP_RESUME2" ] && [ -f $SWSUSP_ROOT/resume2 ] && \
    	echo $SWSUSP_RESUME2 > $SWSUSP_ROOT/resume2

    [ -n "$SWSUSP_POWERDOWN_METHOD" ] && [ -f $SWSUSP_ROOT/powerdown_method ] && \
	echo $SWSUSP_POWERDOWN_METHOD > $SWSUSP_ROOT/powerdown_method

    [ -n "$SWSUSP_EXTRA_PROC_SETTINGS" ] && [ -f "$SWSUSP_EXTRA_PROC_SETTINGS" ] && \
	. $SWSUSP_EXTRA_PROC_SETTINGS

    return 0
}

SwsuspIsAtLeastVersion() {
    ver=`awk 'BEGIN{FS="[^0-9]"}{print($1*0x1000000)+($2*0x10000)+($3*0x100)+$4}' $SWSUSP_ROOT/version`
    [ $ver -ge $1 ] && return 0
    return 1
}

DoSwsusp2() {
    local error
    if [ -n "$SWSUSP2_BUG_REPORT" ] ; then
	# Dump our debug info now.
	vecho 0 "System information follows. (Please include with bug reports)."
	vecho 0 "--- Hibernate script version: $VERSION"
	[ -f /proc/config.gz ] || vecho 0 "--- kernel config not compiled into kernel. Please attach this separately."
	vecho 0 "--- Modules loaded: "`lsmod|awk 'BEGIN{getline}{print $1}'`
	vecho 0 "--- Active swaps: "
	vcat 0 /proc/swaps
	vecho 0 "--- /proc/cmdline: "`cat /proc/cmdline`
	vecho 0 "--- /proc/cpuinfo:"
	vcat 0 /proc/cpuinfo
	vecho 0 "--- lspci:"
	lspci | vcat 0
	if [ -f /proc/config.gz ] ; then
	    vecho 0 "--- kernel config:"
	    zcat /proc/config.gz | vcat 0
	fi

	# Use a freezer test if we can. Otherwise, just don't suspend.
	if [ -f "$SWSUSP_ROOT/freezer_test" ] ; then
	    echo 1 > /proc/software_suspend/freezer_test
	    # We'll obtain debug_info from dmesg
	else
	    SWSUSP2_NO_SUSPEND=1
	    if [ -f "$SWSUSP_ROOT/debug_info" ] ; then
		vecho 0 "--- /proc/software_suspend/debug_info:"
		vcat 0 $SWSUSP_ROOT/debug_info
	    fi
	fi
	vecho 1 "$EXE: Performing a freezer_test..."
    fi
    if [ -z "$SWSUSP2_NO_SUSPEND" ] ; then
	vecho 1 "$EXE: Activating suspend ..."
	SaveDmesg
	error=`DoSuspend`
	[ -n "$error" ] && [ $error -ne 0 ] && EXIT_CODE=4
	if ! PrintErrors $error || [ -n "$SWSUSP2_BUG_REPORT" ]; then
	    OutputDmesgChanges
	fi
	CleanupDmesg
    else
	vecho 1 "$EXE: Not actually suspending (--no-suspend given)"
    fi
    [ -f "$SWSUSP_ROOT/freezer_test" ] && echo 0 > /proc/software_suspend/freezer_test
    return 0
}

ChangeToSwsuspVT() {
    if [ -n "$SWSUSP_FORCE_CHVT" ] ; then
	if command -v fgconsole > /dev/null 2>&1 ; then
	    SWSUSP_ORIGINAL_VT=`fgconsole`
	else
	    SWSUSP_ORIGINAL_VT=1
	fi
	vecho 3 "swsusp2_15: changing console from $SWSUSP_ORIGINAL_VT to 63"
	chvt 63
	# Turn off unicode on this VT, as it makes swsusp output ugly.
	/bin/echo -ne '\033%@' > /dev/tty63
    fi
    return 0
}

ChangeFromSwsuspVT() {
    if [ -n "$SWSUSP_ORIGINAL_VT" ] ; then
	vecho 3 "swsusp2_15: changing console back to $SWSUSP_ORIGINAL_VT"
	chvt $SWSUSP_ORIGINAL_VT
    fi
    return 0
}

SaveDmesg() {
    # Save dmesg for later diffing.
    DMESG_ORIG=`mktemp /tmp/tmp.hibernate.XXXXXX`
    if ! dmesg > $DMESG_ORIG ; then
	rm -f $DMESG_ORIG
	DMESG_ORIG=
    fi
    return 0
}

OutputDmesgChanges() {
    [ -z "$DMESG_ORIG" ] && return 0
    local DMESG_CMP

    DMESG_CMP=`mktemp /tmp/tmp.hibernate.XXXXXX`
    # Rip out the relevant bits from the diff
    if dmesg | diff $DMESG_ORIG - | \
	awk 'BEGIN { chunks = 0 } 
            /^[0-9]/ { chunks += 1 }
	    /^> / { if (chunks == 2) print(substr($0, 2)) }
	    END { if (chunks == 2) exit 0; else exit 1 }' > $DMESG_CMP
    then
	# Exit code indicates the diff was useful. Log it (manually for speed).
	local diff_loglevel=1
	[ -n "$SWSUSP2_BUG_REPORT" ] && diff_loglevel=0
	vecho $diff_loglevel "---- Output from dmesg: ----"
	vcat $diff_loglevel $DMESG_CMP
	vecho $diff_loglevel "---- End of dmesg output ----"
    else
	vecho 1 "Couldn't extract useful information from dmesg. Not logging here."
    fi
    rm -f $DMESG_CMP

    return 0
}

CleanupDmesg() {
    [ -n "$DMESG_ORIG" ] && rm -f $DMESG_ORIG
    return 0
}

# DoSuspend: activates the suspend and echo's the error code to be processed by
# PrintErrors. We can't just return it, because error codes may be > 255
DoSuspend() {
    # Some versions of Software Suspend didn't clear this in certain cases:
    echo 0 > /proc/software_suspend/last_result

    if [ -f $SWSUSP_ROOT/do_suspend ] ; then
	echo > $SWSUSP_ROOT/do_suspend
    else
	echo > $SWSUSP_ROOT/activate
    fi
    read REPLY < $SWSUSP_ROOT/last_result
    echo $REPLY

    return 0
}

# PrintAnErrorString <bit value>: prints a string corresponding to the relevant
# bit in an error code. These match up with the SUSPEND_* values in
# include/linux/suspend-debug.h
PrintAnErrorString() {
    case "$1" in
	0) ERROR_TEXT="${ERROR_TEXT}Suspend was aborted (see dmesg).\n"
	;;
	1) ERROR_TEXT="${ERROR_TEXT}Suspend was aborted by user (see dmesg if unexpected).\n"
	;;
	2) ERROR_TEXT="${ERROR_TEXT}No swapspace was available. Try swapon?\n"
	;;
	3) ERROR_TEXT="${ERROR_TEXT}Not enough swapspace available. Free some memory?\n"
	;;
	4) ERROR_TEXT="${ERROR_TEXT}Freezing processes failed. Wacky driver problems :( (see dmesg)\n"
	;;
	5) ERROR_TEXT="${ERROR_TEXT}Internal error - an unexpected memory allocation occured. Driver problems? (see dmesg)\n"
	;;
	6) ERROR_TEXT="${ERROR_TEXT}Image has been kept as requested.\n"
	;;
	7) ERROR_TEXT="${ERROR_TEXT}Suspend would have eaten memory. Yumm....\n"
	;;
	8) ERROR_TEXT="${ERROR_TEXT}Unable to free enough memory.\n"
	;;
	*) ERROR_TEXT="${ERROR_TEXT}Unknown error! (see dmesg?)\n"
	;;
    esac
    return 0
}

# PrintErrors <last_result value>: prints the list of errors associated with a
# given result code. Returns 1 if dmesg output should be given (for failure
# cases)
PrintErrors() {
    local code bit_num

    code="$1"
    [ -n "$code" ] && [ "$code" -eq 0 ] && return 0

    ERROR_TEXT="${ERROR_TEXT}$EXE: Suspend reported the following errors:\n"

    if [ -z "$code" ] ; then
	ERROR_TEXT="${ERROR_TEXT}\n - No status was returned. Might be a buggy or incompatible kernel?"
	/bin/echo -ne $ERROR_TEXT
	return 1
    fi

    # A special case for "suspend aborted" and "suspend aborted by user"
    # because it'd look silly to have both.
    if [ $(($code&3)) -eq 3 ] ; then
	ERROR_TEXT="${ERROR_TEXT} - "
	PrintAnErrorString 1 # aborted by user
	/bin/echo -ne $ERROR_TEXT
	return 0
    fi

    bit_num=0
    while [ "$code" -ne 0 ] ; do
	[ $(($code&1)) -eq 1 ] && echo -n " - " && PrintAnErrorString "$bit_num"

	bit_num=$(($bit_num+1))
	code=$(($code>>1))
    done
    /bin/echo -ne "$ERROR_TEXT"
    return 1
}

# GetInterfaceVersion: returns the interface version of the swsusp
# implementation in the kernel. This returns 0 if there is no swsusp in the
# kernel (note, this is interpreted as "true" in shell-speak)
GetInterfaceVersion() {
    [ -d "$SWSUSP_ROOT" ] || return 0
    [ -f "$SWSUSP_ROOT/interface_version" ] || return 0
    read REPLY < $SWSUSP_ROOT/interface_version
    return $REPLY
}

# EnsureSwsusp2Capable: makes sure we have a swsusp-capable kernel. Stops the
# script with an error message if we don't. Also ensure's we have root -
# (even though the actual suspend might not need it, everything else will)
EnsureSwsusp2Capable() {
    # Test for *any* recent swsusp support
    local ver
    GetInterfaceVersion
    ver=$?
    if [ "$ver" -eq 0 ] ; then
	cat <<EOT
Your kernel does not have any recent Software Suspend 2 support compiled in.
Please follow the HOWTO linked from http://softwaresuspend.berlios.de/ for
instructions on how to compile Software Suspend into your kernel.
EOT
	return 2
    fi

    if [ -f "$SWSUSP_ROOT/activate" ] || [ -f "$SWSUSP_ROOT/do_suspend" ] ; then
	if [ ! -f "$SWSUSP_ROOT/version" ] ; then
	    cat <<EOT
Can not find $SWSUSP_ROOT/version. Have you loaded the suspend_core
module?

EOT
	    return 1 # abort unless forced
	fi
    fi

    # Check the interface version matches. Warn if it doesn't.
    if [ $ver -lt "$SWSUSP_INTERFACE_VERSION_MIN" ] || [ $ver -gt "$SWSUSP_INTERFACE_VERSION_MAX" ] ; then
	cat <<EOT
WARNING: The swsusp2 scriptlet was written for a different swsusp2 interface
	 version from the one in your running kernel. This scriptlet was
	 written for version between $SWSUSP_INTERFACE_VERSION_MIN and $SWSUSP_INTERFACE_VERSION_MIN where as the version running
	 in your kernel is $ver. Things may not work as expected, but proceeding
	 anyway ...

EOT
    fi

    # Figure out if we need to handle VT switching ourselves (if version
    # >= 2.0.0.103)
    SwsuspIsAtLeastVersion $((0x02000067)) && SWSUSP_FORCE_CHVT=1

    # If we have the resume2 proc entry, we can do some further tests
    # Otherwise, bail gracefully
    [ -f $SWSUSP_ROOT/resume2 ] || return 0

    # If we're going to set resume2, we needn't care about this.
    [ -n "$SWSUSP_RESUME2" ] && return 0

    # See if we have been given a resume2 line
    read REPLY < $SWSUSP_ROOT/resume2
    if [ -z "$REPLY" ] ; then
	cat <<EOT
You haven't specified a resume2= parameter on your kernel command line

Your GRUB or LILO config should have something like resume2=swap:/dev/hdaX
where /dev/hdaX is your swap partition. You will then need to either reboot
after doing so or set it manually (this time only) using:
    echo swap:/dev/hdaX > $SWSUSP_ROOT/resume2
EOT
	return 2
    fi
    return 0
}

Swsusp2LoadModules() {
    local i
    local ret
    ret=0
    for i in $SWSUSP_LOAD_MODULES ; do
	vecho 2 -n "Loading suspend module $i ... "
	if modprobe $i > /dev/null 2>&1 ; then
	    vecho 2
	else
	    vecho 2 "failed."
	    ret=1
	    # Don't abort immediately, because we might be using force.
	    # So we may as well load all the modules.
	fi
    done
    # Ensure we really have loaded the modules (avoid race conditions)
    i=0
    while ! [ -f $SWSUSP_ROOT/resume2 ] && [ $i -lt 3 ] ; do
	sleep 1
	i=$(($i+1))
    done
    return $ret
}

Swsusp2UnloadModules() {
    for i in $SWSUSP_LOAD_MODULES ; do
	vecho 2 "Unloading suspend module $i ... "
	rmmod `FindModuleDeps $i` > /dev/null 2>&1
    done
    return 0
}

Swsusp2SetupFilewriter() {
    if ! [ -f "$SWSUSP_ROOT/filewriter_location" ] ; then
	vecho 0 "$EXE: WARNING: Filewriter location given, but kernel does not have filewriter"
	vecho 0 "$EXE: support. Ignoring."
	return 0
    fi

    if [ -z "$SWSUSP_FILEWRITER_LOC" ] ; then
	vecho 0 "$EXE: Empty filewriter location given!"
	exit 1
    fi
    if [ -e "$SWSUSP_FILEWRITER_LOC" ] && [ -d "$SWSUSP_FILEWRITER_LOC" ] ; then
	vecho 0 "$EXE: Filewriter location given is a directory!"
	exit 1
    fi
    if ! [ -w "$SWSUSP_FILEWRITER_LOC" ] ; then
	vecho 0 "$EXE: Filewriter location is unwritable!"
	exit 1
    fi
    case "`dd \"if=$SWSUSP_FILEWRITER_LOC\" bs=8 count=1`" in
	Suspend2)
	    # We're good to go.
	    ;;
	HaveImage)
	    # Eeek! There's already an image here. Erase it using dd to
	    # reliably preserve the starting block.
	    vecho 1 "$EXE: Killing existing filewriter image."
	    if ! echo "Suspend2" | dd "of=$SWSUSP_FILEWRITER_LOC" bs=8 count=1 2>/dev/null ; then
		vecho 0 "$EXE: Failed to kill existing image!"
		exit 1
	    fi
	    ;;
	"")
	    # An empty file. Capitalise on this.
	    if ! echo "Suspend2" | dd "of=$SWSUSP_FILEWRITER_LOC" bs=8 count=1 2>/dev/null ; then
		vecho 0 "$EXE: Failed to create filewriter image for suspending!"
		exit 1
	    fi
	    ;;
	*)
	    # Something entirely different. We probably don't want to use this file!
	    vecho 0 "$EXE: Filewriter image ($SWSUSP_FILEWRITER_LOC) is unrecognised."
	    vecho 0 "$EXE: I'm not even going to attempt to use this file to suspend to."
	    vecho 0 "$EXE: Please erase the contents of the existing file if you believe it"
	    vecho 0 "$EXE: to be safe, otherwise, please specify a new file."
	    exit 1
	    ;;
    esac

    if ! echo "$SWSUSP_FILEWRITER_LOC" > $SWSUSP_ROOT/filewriter_location ; then
	vecho 0 "$EXE: Failed to set filewriter location! Aborting."
	return 2 # abort if forced
    fi

    # Now verify header locations is correct.

    # Coming soon ...
}

# $Id$
