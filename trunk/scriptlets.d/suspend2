# -*- sh -*-
# vim:ft=sh:ts=8:sw=4:noet


AddTerminationHandler Swsusp2Termination
AddConfigHandler Swsusp2ConfigEnabler
AddOptionHandler Swsusp2OptionHandler

AddConfigHelp "UseSuspend2 <boolean>" "Enable/disable the use of Software Suspend 2 to suspend."

AddConfigHelp "Reboot <boolean> (requires UseSuspend2 on)" "Controls whether or not Software Suspend 2 should reboot after suspending. Setting this to yes will force a reboot. Setting this to no will force shutting down. Omitting this option will leave rebooting behaviour unchanged."
AddShortOption "r::"
AddLongOption "reboot::"
AddOptionHelp "-r[0|1], --reboot[=<0|1>] (requires UseSuspend2 on)" "If 0 is specified, disables rebooting after suspend, regardless of the Reboot option in the configuration file. If 1 or omitted, will force a reboot after suspending."

AddConfigHelp "EnableEscape <boolean> (requires UseSuspend2 on)" "If specified, allows (or disallows) the use of the escape key to abort a suspend. If this line is not specified, the Escape key's behaviour is unchanged."

AddConfigHelp "DefaultConsoleLevel <N> (requires UseSuspend2 on)" "If specified, sets the default console level. 0 gives a progress bar. 1 gives a progress bar with numbers. 2 or higher give increasing amounts of debugging. If this line is not specified, the default console level is unchanged."

AddConfigHelp "ImageSizeLimit nocache|<NN> (requires UseSuspend2 on)" "If specified, sets an upper limit on the size of the suspend image written (in megabytes). If set to \"nocache\", caches and buffers will not be saved - resulting in a faster suspend and resume at the possible expense of system responsiveness immediately after resuming. If set to 0, no limit is imposed. If this line is not specified, the existing image size limit is unchanged."

AddConfigHelp "AsyncIOLimit <N> (requires UseSuspend2 on)" "Deprecated since 2.1.5.11 (hence won't do anything if set). Limit the number of I/O operations that Software Suspend 2 will have queued at once. Lowering this value has resolved hangs when reading or writing caches for some people. Try values like 64, 32 and 8."

AddConfigHelp "Swsusp2AllSettings <params> (requires UseSuspend2 on)" "If specified, sets all of the settings for Software Suspend 2 at once. The parameter should be the contents of $SWSUSP_ROOT/all_settings after you have set your desired settings manually."

AddConfigHelp "Swsusp2AllSettingsFile <filename> (requires UseSuspend2 on)" "If specified, sets all of the settings for Software Suspend 2 and all its plugins at once, from the given file. The parameter should be the path to a file containing the result of \"cat $SWSUSP_ROOT/all_settings > <filename>\"after you have set your desired settings manually."

AddConfigHelp "SuspendDevice <device> (requires UseSuspend2 on)" "If specified, sets the suspend device by writing to the resume[2] entry in $SWSUSP_ROOT. This does not automatically set the resuming device - you will need to make sure your bootloader or initrd script does this."

AddConfigHelp "FilewriterLocation <filename> <size in MB> (requires UseSuspend2 on)" "This option sets up the given filename to act as a destination file for writing the suspend image to, and verifies that it can act as a valid destination. If the file does not exist, the file is created. This option is only relevant if you are using the filewriter plugin for Software Suspend."

AddConfigHelp "VerifyFilewriterResume2 <boolean> (requires UseSuspend2 on)" "When this option is on, you will be prompted if your current kernel command-line does not match the correct resume[2] for the filewriter. This option is on by default."

AddConfigHelp "LoadSuspendModules <module name> [...] (requires UseSuspend2 on)" "Loads the given modules before even detecting Software Suspend. This may be required when Software Suspend is compiled as modules that need to be loaded prior to suspending."
AddConfigHelp "UnloadSuspendModulesAfterResume <boolean> (requires UseSuspend2 on)" "If yes, will unload the Software Suspend modules mentioned above after resuming."

AddConfigHelp "PowerdownMethod <0|3|4|5> (requires UseSuspend2 on)" "Allows you to choose what Software Suspend 2 should do after writing its image to disk. 3/4/5 will only work if you have ACPI enabled in your kernel. 3/4/5 correspond to the ACPI states S3 (suspend-to-RAM), S4 (suspend-to-disk), and S5 (power off). Choosing 3 will request your machine to enter the S3 Suspend-to-RAM state if it is supported - this allows you drastically cut the resume time waiting for your BIOS but still consumes power whilst hibernated (though the image is not lost should power run out). Choosing 4 will cause your machine to enter an S4 sleep state which may also reduce the resume time without using any power whilst hibernated. Choosing 5 will cause your machine to switch off after suspending (traditional method) but might still cause your machine to resume when you open the lid. 0 bypasses ACPI and shuts off the machine completely."

AddConfigHelp "Compressor none|<compressor name> (requires UseSuspend2 on)" "Sets the compression algorithm to use for compressing the memory image. If set to \"none\", disables compression. Otherwise, the compressor name must be listed in /proc/crypto. This will also try to load the module if not available. (Only for Software Suspend 2.1.9.5 or newer)."

AddConfigHelp "Encryptor none|<encryptor name> (requires UseSuspend2 on)" "Sets the encryption algorithm to use for encrypting the memory image. If set to \"none\", disables encryption. Otherwise, the cipher name must be listed in /proc/crypto. This will also try to load the module if not available. You will probably require more options than just this to fully use encryption. These will be introduced in the next version of hibernate, but for now you can set them using the \"ProcSetting\" option if you know what you are doing. (Only for Software Suspend 2.1.9.5 or newer)."

AddConfigHelp "ProcSetting <entry name> <value> (requires UseSuspend2 on)" "Sets the value of $SWSUSP_ROOT/<entry_name> to <value> upon suspending. You can use this setting to set parameters that can't be configured anywhere else in this script. This is executed after all other settings have been set."

AddShortOption "n"
AddLongOption "no-suspend"

AddLongOption "save-settings::"
AddOptionHelp "--save-settings [filename] (requires UseSuspend2 on)" "Saves all the current settings for Software Suspend 2 into a file (default: $SWSUSP_DEFAULT_ALL_SETTINGS_FILE)"

AddLongOption "bug-report"
AddOptionHelp "--bug-report (requires UseSuspend2 on)" "Gathers a bunch of information about your machine and writes it to standard output. Please attach this information along with any bug reports to the Software Suspend mailing list."

Swsusp2Termination() {
    # rmmod rather than modprobe -r because the later might
    # remove more modules than we want to remove.
    for mod in ${SWSUSP_RMOD} ; do
	/sbin/rmmod ${mod}
    done

    return 0
}

Swsusp2ConfigEnabler() {
    [ "$1" != "usesuspend2" ] && [ "$1" != "useswsusp2" ] && return 1
    BoolIsOn "$1" "$2" || return 0
    [ -n "$USING_SWSUSP2" ] && return 0

    # Load the suspend modules if necessary
    # Order is important - dependent modules later than what they depend on.
    SWSUSP_MODS="suspend_core suspend_block_io suspend_file suspend_swap suspend_compress suspend_userui tuxonice_core tuxonice_block_io tuxonice_file tuxonice_swap tuxonice_compress tuxonice_userui"
    SWSUSP_RMOD=
    for mod in ${SWSUSP_MODS} ; do
	/sbin/modprobe --first-time "${mod}" >/dev/null 2>&1  && SWSUSP_RMOD="${mod} ${SWSUSP_RMOD}"
    done

    # Detect where suspend2 is these days.
    if [ -d "/sys/power/tuxonice/" ] ; then
	SWSUSP_ROOT="/sys/power/tuxonice"
    elif [ -d "/sys/power/suspend2/" ] ; then
	SWSUSP_ROOT="/sys/power/suspend2"
    elif [ -d "/proc/swsusp/" ] ; then
	SWSUSP_ROOT="/proc/swsusp"
    elif [ -d "/proc/software_suspend" ] ; then
	SWSUSP_ROOT="/proc/software_suspend"
    else
	SWSUSP_ROOT="/proc/suspend2"
    fi
    
    COMPRESSION_ROOT="$SWSUSP_ROOT"
    ENCRYPTION_ROOT="$SWSUSP_ROOT"
    FILEWRITER_ROOT="$SWSUSP_ROOT"
    SWAPWRITER_ROOT="$SWSUSP_ROOT"
    UI_ROOT="$SWSUSP_ROOT"
    STORAGEMAN_ROOT="$SWSUSP_ROOT"
    [ -d "$SWSUSP_ROOT/compression/" ] && COMPRESSION_ROOT="$SWSUSP_ROOT/compression"
    [ -d "$SWSUSP_ROOT/encryption/" ] && ENCRYPTION_ROOT="$SWSUSP_ROOT/encryption"
    [ -d "$SWSUSP_ROOT/filewriter/" ] && FILE_DIR="filewriter"
    [ -d "$SWSUSP_ROOT/swapwriter/" ] && SWAP_DIR_ROOT="swapwriter"
    [ -d "$SWSUSP_ROOT/file/" ] && FILE_DIR="file"
    [ -d "$SWSUSP_ROOT/swap/" ] && SWAP_DIR="swap"
    [ -d "$SWSUSP_ROOT/user_interface/" ] && UI_ROOT="$SWSUSP_ROOT/user_interface"
    [ -d "$SWSUSP_ROOT/storage_manager/" ] && STORAGEMAN_ROOT="$SWSUSP_ROOT/storage_manager"

    [ -n "$FILE_DIR" ] && FILEWRITER_ROOT="$SWSUSP_ROOT/$FILE_DIR"    
    [ -n "$SWAP_DIR" ] && SWAPWRITER_ROOT="$SWSUSP_ROOT/$SWAP_DIR"    
    SWSUSP_DEFAULT_ALL_SETTINGS_FILE="$SWSUSP_D/swsusp2-all-settings.conf"
    HIBERNATE_FILEWRITER_TRAIL="/var/run/suspend2_filewriter_image_exists"

    if [ -n "$NO_COMPLAIN_UNSUPPORTED" ] ; then
	# Just bail silently if we don't detect it.
	[ -d "$SWSUSP_ROOT" ] || return 0
    fi
    UsingSuspendMethod suspend2
    AddConfigHandler Swsusp2ConfigOptions
    AddSuspendHook 10 EnsureSwsusp2Capable
    AddSuspendHook 97 ChangeToSwsuspVT
    AddSuspendHook 99 DoSwsusp2
    AddResumeHook 97 ChangeFromSwsuspVT
    USING_SWSUSP2=1
    return 0
}

Swsusp2OptionHandler() {
    # Don't parse options if we're not being used.
    [ -z "$USING_SWSUSP2" ] && return 1

    case $1 in
	-r|--reboot)
	    if [ -z "$2" ] ; then
		# Cmd-line options will always override config file
		OPT_REBOOT=1
	    else
		BoolIsOn "-r" "$2" && OPT_REBOOT=1 || OPT_REBOOT=0
	    fi
	    ;;
	-n|--no-suspend)
	    SWSUSP2_NO_SUSPEND=1
	    ;;
	--save-settings)
	    if [ -n "$2" ] ; then
		SWSUSP2_SAVE_SETTINGS_FILE="$2"
	    else
		SWSUSP2_SAVE_SETTINGS_FILE="$SWSUSP_DEFAULT_ALL_SETTINGS_FILE"
	    fi
	    AddSuspendHook 00 Swsusp2SaveSettings
	    ;;
	--bug-report)
	    SWSUSP2_BUG_REPORT=1
	    ;;
	*)
	    return 1
    esac
    return 0
}

Swsusp2ConfigOptions() {
    case $1 in
	reboot)
	    if [ -z "$OPT_REBOOT" ] ; then
		BoolIsOn "$1" "$2" && OPT_REBOOT=1 || OPT_REBOOT=0
	    fi
	    ;;
	enableescape)
	    if [ -z "$OPT_ESCAPE" ] ; then
		BoolIsOn "$1" "$2" && OPT_ESCAPE=1 || OPT_ESCAPE=0
	    fi
	    ;;
	defaultconsolelevel)
	    OPT_CONSOLELEVEL=$2
	    ;;
	imagesizelimit)
	    SWSUSP_IMAGE_SIZE_LIMIT=$2
	    ;;
	asynciolimit)
	    SWSUSP_ASYNC_IO_LIMIT=$2
	    ;;
	suspend2allsettings|swsusp2allsettings)
	    SWSUSP_ALL_SETTINGS=$2
	    ;;
	suspend2allsettingsfile|swsusp2allsettingsfile)
	    SWSUSP_ALL_SETTINGS_FILE=$2
	    if ! [ -r "$SWSUSP_ALL_SETTINGS_FILE" ] ; then
		echo "$EXE: Cannot read all_settings file $SWSUSP_ALL_SETTINGS_FILE"
		return 0
	    fi
	    ;;
	suspenddevice)
	    SWSUSP_RESUME2=$2
	    ;;
	filewriterlocation)
	    SWSUSP_FILEWRITER_LOC=$2
	    SWSUSP_FILEWRITER_SIZE=$3
	    if [ -z "$SWSUSP_FILEWRITER_LOC" ] ; then
		vecho 0 "$EXE: Empty filewriter location given!"
		exit 1
	    fi
	    if [ -e "$SWSUSP_FILEWRITER_LOC" ] && [ -d "$SWSUSP_FILEWRITER_LOC" ] ; then
		vecho 0 "$EXE: Filewriter location given is a directory!"
		exit 1
	    fi
	    if [ -e "$SWSUSP_FILEWRITER_LOC" ] && ! [ -w "$SWSUSP_FILEWRITER_LOC" ] ; then
		vecho 0 "$EXE: Filewriter location is unwritable!"
		exit 1
	    fi
	    if ! IsANumber "$SWSUSP_FILEWRITER_SIZE" ; then
		vecho 0 "$EXE: Filewriter size is not numeric!"
		exit 1
	    fi
	    AddSuspendHook 06 Swsusp2SetupFilewriter
	    AddResumeHook 06 Swsusp2CleanupFilewriter
	    ;;
	verifyfilewriterresume2)
	    BoolIsOn "$1" "$2" && return 0
	    SWSUSP_FILEWRITER_NOVERIFY=1
	    ;;
	loadsuspendmodules)
	    AddSuspendHook 05 Swsusp2LoadModules
	    shift
	    SWSUSP_LOAD_MODULES=$@
	    ;;
	unloadsuspendmodulesafterresume)
	    BoolIsOn "$1" "$2" || return 0
	    AddResumeHook 05 Swsusp2UnloadModules
	    ;;
	powerdownmethod)
	    case $2 in
		[03-5])
		    SWSUSP_POWERDOWN_METHOD=$2
		    ;;
		*)
		    echo "$EXE: Invalid value for $1 ($2). Must be 0 3 4 or 5."
		    return 0
		    ;;
	    esac
	    ;;
	compressor|compression)
	    SWSUSP_COMPRESSOR=$2
	    ;;
	encryptor|encryption)
	    SWSUSP_ENCRYPTOR=$2
	    ;;
	procsetting)
	    if [ -z "$OPT_DRY_RUN" ] ; then
		if [ -z "$SWSUSP_EXTRA_PROC_SETTINGS" ] ; then
		    SWSUSP_EXTRA_PROC_SETTINGS=`mktemp /tmp/tmp.hibernate.XXXXXX`
		    cat <<EOT > $SWSUSP_EXTRA_PROC_SETTINGS
# Temporary file for hibernate script.
# If you're reading this then it's probably safe to delete.

EOT
		    AddResumeHook 00 RemoveSwsuspProcCruft
		fi
		shift
		FILE="$1"
		shift
		TARGET="$SWSUSP_ROOT/$FILE"
		if ! [ -f "$TARGET" ] ; then
		    TARGET="`echo $SWSUSP_ROOT/*/$FILE | awk '{print $1}'`"
		    if ! [ -f "$TARGET" ] ; then
			nfile=$FILE
			[ $FILE != ${FILE#userui_} ] && \
			    nfile=user_interface/${FILE#userui_}
			[ $FILE = "storage_manager" ] && \
			    nfile=storage_manager/program
			[ $FILE != ${FILE#filewriter_} ] && \
			    nfile=$FILE_DIR/${FILE#filewriter_}
			[ $FILE != ${FILE#swapwriter_} ] && \
			    nfile=$SWAP_DIR/${FILE#swapwriter_}
			[ $FILE != ${FILE#encryption_} ] && \
			    nfile=encryption/${FILE#encryption_}
			if [ $FILE != ${FILE#disable_} ] ; then
			    nfile=${FILE#disable_}/enabled
			    val=$(($1^1))
			    set -- $val
			fi
			TARGET=$SWSUSP_ROOT/$nfile
		    fi
		fi
		if ! [ -f "$TARGET" ] ; then
		    vecho 0 "suspend2: No $FILE entry available. Not setting."
		else
		    echo "echo \"$*\" > $TARGET" >> $SWSUSP_EXTRA_PROC_SETTINGS
		fi
	    fi
	    ;;
	*)
	    return 1
    esac
    if [ -z "$SWSUSP2_HOOKED" ] ; then
	AddSuspendHook 98 Swsusp2ConfigSet
	SWSUSP2_HOOKED=1
    fi
    return 0
}

Swsusp2SaveSettings() {
    if ! [ -r "$SWSUSP_ROOT/all_settings" ] ; then
	echo "$EXE: Could not read $SWSUSP_ROOT/all_settings."
    elif ! cat "$SWSUSP_ROOT/all_settings" > $SWSUSP2_SAVE_SETTINGS_FILE ; then
	echo "$EXE: Could not save settings. cat failed."
    else
	echo "$EXE: Settings saved to $SWSUSP2_SAVE_SETTINGS_FILE."
    fi
    return 3
}

RemoveSwsuspProcCruft() {
    [ -f "$SWSUSP_EXTRA_PROC_SETTINGS" ] && rm -f $SWSUSP_EXTRA_PROC_SETTINGS
    return 0
}

Swsusp2SetupCryptoAPI() {
    SwsuspIsAtLeastVersion $((0x02010905)) || return

    SWSUSP_MODULES_LOADED=
    if [ -n "$SWSUSP_COMPRESSOR" ] ; then
	if [ "$SWSUSP_COMPRESSOR" != "none" ] ; then
	    if ! grep -q "^name.*: $SWSUSP_COMPRESSOR\$" /proc/crypto ; then
		modprobe $SWSUSP_COMPRESSOR 2>/dev/null 2>&1
		if ! grep -q "^name.*: $SWSUSP_COMPRESSOR\$" /proc/crypto ; then
		    vecho 0 "Warning: Chosen Suspend2 compressor ($SWSUSP_COMPRESSOR) is not available. Compression disabled."
		    SWSUSP_COMPRESSOR=none
		else
		    SWSUSP_MODULES_LOADED="$SWSUSP_COMPRESSOR"
		fi
	    fi
	fi
	if [ "$SWSUSP_COMPRESSOR" != "none" ] ; then
	    compression_algorithm=$SWSUSP_COMPRESSOR
	    disable_value=0
	else
	    compression_algorithm=""
	    disable_value=1
	fi
	if [ -f "$COMPRESSION_ROOT/disable_compression" ] ; then
	    echo $disable_value > $COMPRESSION_ROOT/disable_compression
	elif [ -f "$COMPRESSION_ROOT/enabled" ] ; then
	    echo $(($disable_value^1)) > $COMPRESSION_ROOT/enabled
	fi
	if [ -f "$COMPRESSION_ROOT/compressor" ] ; then
	    echo $compression_algorithm > $COMPRESSION_ROOT/compressor
	elif [ -f "$COMPRESSION_ROOT/algorithm" ] ; then
	    echo $compression_algorithm > $COMPRESSION_ROOT/algorithm
	fi
    fi

    if [ -n "$SWSUSP_ENCRYPTOR" ] ; then
	if [ "$SWSUSP_ENCRYPTOR" != "none" ] ; then
	    if ! grep -q "^name.*: $SWSUSP_ENCRYPTOR\$" /proc/crypto ; then
		modprobe $SWSUSP_ENCRYPTOR 2>/dev/null 2>&1
		if ! grep -q "^name.*: $SWSUSP_ENCRYPTOR\$" /proc/crypto ; then
		    vecho 0 "Warning: Chosen Suspend2 encryptor ($SWSUSP_ENCRYPTOR) is not available. Encryption disabled."
		    SWSUSP_ENCRYPTOR=none
		else
		    SWSUSP_MODULES_LOADED="$SWSUSP_MODULES_LOADED $SWSUSP_ENCRYPTOR"
		fi
	    fi
	fi
	if [ "$SWSUSP_ENCRYPTOR" != "none" ] ; then
	    encryption_algorithm=$SWSUSP_ENCRYPTOR
	    disable_value=0
	else
	    encryption_algorithm=""
	    disable_value=1
	fi
	if [ -f "$ENCRYPTION_ROOT/disable_encryption" ] ; then
	    echo $disable_value > $ENCRYPTION_ROOT/disable_encryption
	elif [ -f "$ENCRYPTION_ROOT/enabled" ] ; then
	    echo $(($disable_value^1)) > $ENCRYPTION_ROOT/enabled
	fi
	if [ -f "$ENCRYPTION_ROOT/encryptor" ] ; then
	    echo $encryption_algorithm > $ENCRYPTION_ROOT/encryptor
	elif [ -f "$ENCRYPTION_ROOT/algorithm" ] ; then
	    echo $encryption_algorithm > $ENCRYPTION_ROOT/algorithm
	fi
    fi
}

Swsusp2ConfigSet() {
    # Apply all settings first before making further changes.
    [ -n "$SWSUSP_ALL_SETTINGS" ] && [ -f $SWSUSP_ROOT/all_settings ] && \
    	echo $SWSUSP_ALL_SETTINGS > $SWSUSP_ROOT/all_settings

    [ -n "$SWSUSP_ALL_SETTINGS_FILE" ] && [ -f $SWSUSP_ROOT/all_settings ] && \
	[ -f "$SWSUSP_ALL_SETTINGS_FILE" ] && \
    	cat $SWSUSP_ALL_SETTINGS_FILE > $SWSUSP_ROOT/all_settings

    if [ "x$SWSUSP_IMAGE_SIZE_LIMIT" = "xnocache" ] ; then
	local field val units result
	local total=0 cached=0 buffers=0 free=0
	while read field val units ; do
	    [ "x$field" = "xMemTotal:" ] && total=$val
	    [ "x$field" = "xMemFree:" ] && free=$val
	    [ "x$field" = "xBuffers:" ] && buffers=$val
	    [ "x$field" = "xCached:" ] && cached=$val
	done < /proc/meminfo
	result=$((($total-$cached-$buffers-$free+10240)/1024))
	vecho 2 "Setting image size limit to $result."
	echo $result > $SWSUSP_ROOT/image_size_limit
    else
	[ -n "$SWSUSP_IMAGE_SIZE_LIMIT" ] && echo $SWSUSP_IMAGE_SIZE_LIMIT > $SWSUSP_ROOT/image_size_limit
    fi

    [ -n "$OPT_REBOOT" ] && [ -f "$SWSUSP_ROOT/reboot" ] && \
	echo $OPT_REBOOT > $SWSUSP_ROOT/reboot

    [ -n "$OPT_ESCAPE" ] && [ -f $UI_ROOT/enable_escape ] && \
	echo $OPT_ESCAPE > $UI_ROOT/enable_escape

    [ -n "$OPT_CONSOLELEVEL" ] && [ -f $UI_ROOT/default_console_level ] && \
	echo $OPT_CONSOLELEVEL > $UI_ROOT/default_console_level

    [ -n "$SWSUSP_ASYNC_IO_LIMIT" ] && [ -f $SWSUSP_ROOT/async_io_limit ] && \
    	echo $SWSUSP_ASYNC_IO_LIMIT > $SWSUSP_ROOT/async_io_limit

    [ -n "$SWSUSP_RESUME2" ] && [ -f $SWSUSP_ROOT/resume ] && \
    	echo $SWSUSP_RESUME2 > $SWSUSP_ROOT/resume

    [ -n "$SWSUSP_RESUME2" ] && [ -f $SWSUSP_ROOT/resume2 ] && \
    	echo $SWSUSP_RESUME2 > $SWSUSP_ROOT/resume2

    [ -n "$SWSUSP_POWERDOWN_METHOD" ] && [ -f $SWSUSP_ROOT/powerdown_method ] && \
	echo $SWSUSP_POWERDOWN_METHOD > $SWSUSP_ROOT/powerdown_method

    Swsusp2SetupCryptoAPI

    [ -n "$SWSUSP_EXTRA_PROC_SETTINGS" ] && [ -f "$SWSUSP_EXTRA_PROC_SETTINGS" ] && \
	. $SWSUSP_EXTRA_PROC_SETTINGS

    return 0
}

SwsuspIsAtLeastVersion() {
    ver=`awk 'BEGIN{FS="[^0-9]"}{print($1*16777216)+($2*65536)+($3*256)+$4}' $SWSUSP_ROOT/version`
    [ $ver -ge $1 ] && return 0
    return 1
}

DoSwsusp2() {
    local error
    if [ -n "$SWSUSP2_BUG_REPORT" ] ; then
	# Dump our debug info now.
	vecho 0 "System information follows. (Please include with bug reports)."
	vecho 0 "--- Hibernate script version: $VERSION"
	[ -f /proc/config.gz ] || vecho 0 "--- kernel config not compiled into kernel. Please attach this separately."
	vecho 0 "--- Modules loaded: "`lsmod|awk 'BEGIN{getline}{print $1}'`
	vecho 0 "--- Active swaps: "
	vcat 0 /proc/swaps
	vecho 0 "--- /proc/cmdline: "`cat /proc/cmdline`
	vecho 0 "--- /proc/cpuinfo:"
	vcat 0 /proc/cpuinfo
	vecho 0 "--- lspci:"
	lspci | vcat 0
	if [ -f /proc/config.gz ] ; then
	    vecho 0 "--- kernel config:"
	    zcat /proc/config.gz | vcat 0
	fi

	# Use a freezer test if we can. Otherwise, just don't suspend.
	if [ -f "$SWSUSP_ROOT/freezer_test" ] ; then
	    /bin/echo 1 > $SWSUSP_ROOT/freezer_test
	    # We'll obtain debug_info from dmesg
	else
	    SWSUSP2_NO_SUSPEND=1
	    if [ -f "$SWSUSP_ROOT/debug_info" ] ; then
		vecho 0 "--- $SWSUSP_ROOT/debug_info:"
		vcat 0 $SWSUSP_ROOT/debug_info
	    fi
	fi
	vecho 1 "$EXE: Performing a freezer_test..."
    fi
    if [ -z "$SWSUSP2_NO_SUSPEND" ] ; then
	vecho 1 "$EXE: Activating suspend ..."
	SaveDmesg
	error=`DoSuspend`
	[ -n "$error" ] && [ $error -ne 0 ] && EXIT_CODE=4
	if ! PrintErrors $error || [ -n "$SWSUSP2_BUG_REPORT" ]; then
	    OutputDmesgChanges
	fi
	CleanupDmesg
    else
	vecho 1 "$EXE: Not actually suspending (--no-suspend given)"
    fi
    [ -f "$SWSUSP_ROOT/freezer_test" ] && echo 0 > $SWSUSP_ROOT/freezer_test
    [ -n "$SWSUSP_MODULES_LOADED" ] && rmmod $SWSUSP_MODULES_LOADED 2>/dev/null
    return 0
}

ChangeToSwsuspVT() {
    if [ -n "$SWSUSP_FORCE_CHVT" ] ; then
	if command -v fgconsole > /dev/null 2>&1 ; then
	    SWSUSP_ORIGINAL_VT=`fgconsole`
	else
	    SWSUSP_ORIGINAL_VT=1
	fi
	vecho 3 "suspend2: changing console from $SWSUSP_ORIGINAL_VT to 63"
	chvt 63
	# Turn off unicode on this VT, as it makes swsusp output ugly.
	/bin/echo -ne '\033%@' > /dev/tty63
    fi
    return 0
}

ChangeFromSwsuspVT() {
    if [ -n "$SWSUSP_ORIGINAL_VT" ] ; then
	vecho 3 "suspend2: changing console back to $SWSUSP_ORIGINAL_VT"
	chvt $SWSUSP_ORIGINAL_VT
    fi
    return 0
}

SaveDmesg() {
    # Save dmesg for later diffing.
    DMESG_ORIG=`mktemp /tmp/tmp.hibernate.XXXXXX`
    if ! dmesg > $DMESG_ORIG ; then
	rm -f $DMESG_ORIG
	DMESG_ORIG=
    fi
    return 0
}

OutputDmesgChanges() {
    [ -z "$DMESG_ORIG" ] && return 0
    local DMESG_CMP

    DMESG_CMP=`mktemp /tmp/tmp.hibernate.XXXXXX`
    # Rip out the relevant bits from the diff
    if dmesg | diff $DMESG_ORIG - | \
	awk 'BEGIN { chunks = 0 } 
            /^[0-9]/ { chunks += 1 }
	    /^> / { if (chunks == 2) print(substr($0, 2)) }
	    END { if (chunks == 2) exit 0; else exit 1 }' > $DMESG_CMP
    then
	# Exit code indicates the diff was useful. Log it (manually for speed).
	local diff_loglevel=1
	[ -n "$SWSUSP2_BUG_REPORT" ] && diff_loglevel=0
	vecho $diff_loglevel "---- Output from dmesg: ----"
	vcat $diff_loglevel $DMESG_CMP
	vecho $diff_loglevel "---- End of dmesg output ----"
    else
	vecho 1 "Couldn't extract useful information from dmesg. Not logging here."
    fi
    rm -f $DMESG_CMP

    return 0
}

CleanupDmesg() {
    [ -n "$DMESG_ORIG" ] && rm -f $DMESG_ORIG
    return 0
}

# DoSuspend: activates the suspend and echo's the error code to be processed by
# PrintErrors. We can't just return it, because error codes may be > 255
DoSuspend() {
    if [ -f $SWSUSP_ROOT/do_hibernate ]; then
	echo > $SWSUSP_ROOT/do_hibernate
    elif [ -f $SWSUSP_ROOT/do_suspend ] ; then
	echo > $SWSUSP_ROOT/do_suspend
    else
	echo > $SWSUSP_ROOT/activate
    fi
    read REPLY < $SWSUSP_ROOT/last_result
    echo $REPLY

    return 0
}

# PrintAnErrorString <bit value>: prints a string corresponding to the relevant
# bit in an error code. These match up with the SUSPEND_* values in
# include/linux/suspend-debug.h
PrintAnErrorString() {
    case "$1" in
	0) ERROR_TEXT="${ERROR_TEXT}Suspend was aborted (see dmesg).\n"
	;;
	1) ERROR_TEXT="${ERROR_TEXT}Suspend was aborted by user (see dmesg if unexpected).\n"
	;;
	2) ERROR_TEXT="${ERROR_TEXT}No swapspace was available. Try swapon?\n"
	;;
	3) ERROR_TEXT="${ERROR_TEXT}Not enough swapspace available. Free some memory?\n"
	;;
	4) ERROR_TEXT="${ERROR_TEXT}Freezing processes failed. Wacky driver problems :( (see dmesg)\n"
	;;
	5) ERROR_TEXT="${ERROR_TEXT}Internal error - an unexpected memory allocation occured. Driver problems? (see dmesg)\n"
	;;
	6) ERROR_TEXT="${ERROR_TEXT}Image has been kept as requested.\n"
	;;
	7) ERROR_TEXT="${ERROR_TEXT}Suspend would have eaten memory. Yumm....\n"
	;;
	8) ERROR_TEXT="${ERROR_TEXT}Unable to free enough memory.\n"
	;;
	9) ERROR_TEXT="${ERROR_TEXT}Failed to setup compression or encryption.\n"
	;;
	10) ERROR_TEXT="${ERROR_TEXT}A suspend is already in progress?\n"
	;;
	11) ERROR_TEXT="${ERROR_TEXT}Some devices refused to suspend (see dmesg).\n"
	;;
	*) ERROR_TEXT="${ERROR_TEXT}Unknown error! (see dmesg?)\n"
	;;
    esac
    return 0
}

# PrintErrors <last_result value>: prints the list of errors associated with a
# given result code. Returns 1 if dmesg output should be given (for failure
# cases)
PrintErrors() {
    local code bit_num

    code="$1"
    [ -n "$code" ] && [ "$code" -eq 0 ] && return 0

    ERROR_TEXT="${ERROR_TEXT}$EXE: Suspend reported the following errors:\n"

    if [ -z "$code" ] ; then
	ERROR_TEXT="${ERROR_TEXT}\n - No status was returned. Might be a buggy or incompatible kernel?"
	/bin/echo -ne $ERROR_TEXT
	return 1
    fi

    # A special case for "suspend aborted" and "suspend aborted by user"
    # because it'd look silly to have both.
    if [ $(($code&3)) -eq 3 ] ; then
	ERROR_TEXT="${ERROR_TEXT} - "
	PrintAnErrorString 1 # aborted by user
	/bin/echo -ne $ERROR_TEXT
	return 0
    fi

    bit_num=0
    while [ "$code" -ne 0 ] ; do
	[ $(($code&1)) -eq 1 ] && ERROR_TEXT="${ERROR_TEXT} - " && PrintAnErrorString "$bit_num"

	bit_num=$(($bit_num+1))
	code=$(($code>>1))
    done
    /bin/echo -ne "$ERROR_TEXT"
    return 1
}

# EnsureSwsusp2Capable: makes sure we have a swsusp-capable kernel. Stops the
# script with an error message if we don't. Also ensure's we have root -
# (even though the actual suspend might not need it, everything else will)
EnsureSwsusp2Capable() {
    # Test for *any* recent swsusp support
    local ver
    if ! [ -d "$SWSUSP_ROOT" ] ; then
	cat <<EOT
Your kernel does not appear to have Software Suspend 2 support compiled in.
Please follow the HOWTO linked from http://www.suspend2.net/ for instructions
on how to compile Software Suspend into your kernel.
EOT
	return 2
    fi

    if [ -f "$SWSUSP_ROOT/activate" ] || [ -f "$SWSUSP_ROOT/do_suspend" ] || [ -f "$SWSUSP_ROOT/do_hibernate" ]; then
	if [ ! -f "$SWSUSP_ROOT/version" ] ; then
	    cat <<EOT
Can not find $SWSUSP_ROOT/version. Have you loaded the suspend_core
module?

EOT
	    return 1 # abort unless forced
	fi
    fi

    # Figure out if we need to handle VT switching ourselves (if version
    # >= 2.0.0.103, and the xhacks scriptlet didn't do it for us)
    SwsuspIsAtLeastVersion $((0x02000067)) && [ x"$XHACKS_LEAVE_X" != "x1" ] && \
	SWSUSP_FORCE_CHVT=1

    # If we have the resume2 proc entry, we can do some further tests
    # Otherwise, bail gracefully
    if [ -f $SWSUSP_ROOT/resume2 ]; then
        RESUME2_FILE=resume2
    elif [ -f $SWSUSP_ROOT/resume ]; then
        RESUME2_FILE=resume
    fi

    [ -n $RESUME2_FILE ] || return 0

    # If we're going to set resume2, we needn't care about this.
    [ -n "$SWSUSP_RESUME2" ] && return 0

    # See if we have been given a resume2 line
    read REPLY < $SWSUSP_ROOT/$RESUME2_FILE
    if [ -z "$REPLY" ] ; then
	cat <<EOT
You haven't specified a resume2= parameter on your kernel command line

Your GRUB or LILO config should have something like $RESUME2_FILE=swap:/dev/hdaX
where /dev/hdaX is your swap partition. You will then need to either reboot
after doing so or set it manually (this time only) using:
    echo swap:/dev/hdaX > $SWSUSP_ROOT/$RESUME2_FILE
EOT
	return 2
    fi
    return 0
}

Swsusp2LoadModules() {
    local i
    local ret
    ret=0
    for i in $SWSUSP_LOAD_MODULES ; do
	vecho 2 -n "Loading suspend module $i ... "
	if modprobe $i > /dev/null 2>&1 ; then
	    vecho 2
	else
	    vecho 2 "failed."
	    ret=1
	    # Don't abort immediately, because we might be using force.
	    # So we may as well load all the modules.
	fi
    done
    # Ensure we really have loaded the modules (avoid race conditions)
    i=0
    while ! [ -f $SWSUSP_ROOT/$RESUME2_FILE ] && [ $i -lt 3 ] ; do
	sleep 1
	i=$(($i+1))
    done
    return $ret
}

Swsusp2UnloadModules() {
    for i in $SWSUSP_LOAD_MODULES ; do
	vecho 2 "Unloading suspend module $i ... "
	rmmod `FindModuleDeps $i` > /dev/null 2>&1
    done
    return 0
}

Swsusp2SetupFilewriter() {
    local ft_entry
    ft_entry=
    [ -f "$FILEWRITER_ROOT/filewriter_target" ] && \
	ft_entry="$FILEWRITER_ROOT/filewriter_target"
    [ -f "$FILEWRITER_ROOT/target" ] && \
	ft_entry="$FILEWRITER_ROOT/target"

    if [ -z $ft_entry ] ; then
	vecho 0 "$EXE: WARNING: Filewriter location given, but kernel does not have filewriter"
	vecho 0 "$EXE: support. Ignoring."
	return 0
    fi

    if ! [ -e "$SWSUSP_FILEWRITER_LOC" ] ; then
	vecho 0 "$EXE: Creating $SWSUSP_FILEWRITER_SIZE MB filewriter target."
	{
	    echo Suspend2
	    dd if=/dev/zero bs=1M count=$SWSUSP_FILEWRITER_SIZE 2>/dev/null
	} > $SWSUSP_FILEWRITER_LOC
	sync
    fi

    case "`dd \"if=$SWSUSP_FILEWRITER_LOC\" bs=8 count=1 2>/dev/null`" in
	Suspend2)
	    # We're good to go.
	    vecho 1 "$EXE: Detected filewriter image ready for use."
	    ;;
	HaveImag)
	    # Eeek! There's already an image here. Erase it using dd to
	    # reliably preserve the starting block.
	    vecho 1 "$EXE: Killing existing filewriter image."
	    if ! /bin/echo -ne "Suspend2\n\0\0" | dd "of=$SWSUSP_FILEWRITER_LOC" bs=11 count=1 conv=notrunc 2>/dev/null ; then
		vecho 0 "$EXE: Failed to kill existing image!"
		return 2 # Abort even with force
	    fi
	    ;;
	*)
	    # Something entirely different. We probably don't want to use this file!
	    vecho 0 "$EXE: Filewriter image ($SWSUSP_FILEWRITER_LOC) is unrecognised."
	    vecho 0 "$EXE: I'm not even going to attempt to use this file to suspend to."
	    vecho 0 "$EXE: Please erase the contents of the existing file if you believe it"
	    vecho 0 "$EXE: to be safe, otherwise, please specify a new file."
	    return 2 # Abort even with force
	    ;;
    esac

    if ! echo "$SWSUSP_FILEWRITER_LOC" > $ft_entry ; then
	vecho 0 "$EXE: Failed to set filewriter location! Aborting."
	return 2 # abort even if forced
    fi

    # Leave a note so that the file can be cleaned up on a fresh reboot.
    echo "$SWSUSP_FILEWRITER_LOC" > $HIBERNATE_FILEWRITER_TRAIL
    chmod 600 $HIBERNATE_FILEWRITER_TRAIL

    # Don't overwrite the resume2 line now.
    SWSUSP_RESUME2="$new_resume2"

    # Now verify our resume2 is correct unless told otherwise.
    [ x"$SWSUSP_FILEWRITER_NOVERIFY" = "x1" ] && return 0

    local new_resume2
    new_resume2="`cat $SWSUSP_ROOT/$RESUME_FILE`"
    if [ -z "$new_resume2" ] ; then
	vecho 0 "ABORTING: $SWSUSP_ROOT/$RESUME_FILE did not return a valid result."
	return 2 # abort even if forced
    fi

    if ! grep "$new_resume2" /proc/cmdline ; then
	filewriter_target=`cat $SWSUSP_ROOT/$RESUME_FILE`
	vecho 0 "ABORTING: $RESUME_FILE is not setup correctly. Unless you have setup your bootloader"
	vecho 0 "          correctly, resuming will most likely fail. To correct this, add"
	vecho 0 "          \"$RESUME_FILE=$filewriter_target\" to your kernel command line in your"
	vecho 0 "          LILO or GRUB configuration file and reboot."
	return 2 # abort even if forced
    fi

    return 0
}

Swsusp2CleanupFilewriter() {
    rm -f $HIBERNATE_FILEWRITER_TRAIL
}

# $Id$
