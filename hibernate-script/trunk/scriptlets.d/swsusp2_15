# -*- sh -*-
# vim:ft=sh:ts=8:sw=4:noet

SWSUSP_INTERFACE_VERSION_MIN=15
SWSUSP_INTERFACE_VERSION_MAX=15

# Detect the new /proc root.
if [ -d "/proc/software_suspend/" ] ; then
    SWSUSP_ROOT="/proc/software_suspend"
else
    SWSUSP_ROOT="/proc/swsusp"
fi

AddConfigHandler Swsusp2ConfigEnabler
AddOptionHandler Swsusp2OptionHandler

AddConfigHelp "UseSwsusp2 <boolean>" "Enable/disable the use of Software Suspend 2 to suspend."

AddConfigHelp "Reboot <boolean> (requires UseSwsusp2 on)" "Controls whether or not Software Suspend 2 should reboot after suspending. Setting this to yes will force a reboot. Setting this to no will force shutting down. Omitting this option will leave rebooting behaviour unchanged."
AddShortOption "r::"
AddLongOption "reboot::"
AddOptionHelp "-r[0|1], --reboot[=<0|1>] (requires UseSwsusp2 on)" "If 0 is specified, disables rebooting after suspend, regardless of the Reboot option in the configuration file. If 1 or omitted, will force a reboot after suspending."

AddConfigHelp "EnableEscape <boolean> (requires UseSwsusp2 on)" "If specified, allows (or disallows) the use of the escape key to abort a suspend. If this line is not specified, the Escape key's behaviour is unchanged."

AddConfigHelp "DefaultConsoleLevel <N> (requires UseSwsusp2 on)" "If specified, sets the default console level. 0 gives a progress bar. 1 gives a progress bar with numbers. 2 or higher give increasing amounts of debugging. If this line is not specified, the default console level is unchanged."

AddConfigHelp "ImageSizeLimit nocache|<NN> (requires UseSwsusp2 on)" "If specified, sets an upper limit on the size of the suspend image written (in megabytes). If set to \"nocache\", caches and buffers will not be saved - resulting in a faster suspend and resume at the possible expense of system responsiveness immediately after resuming. If set to 0, no limit in imposed. If this line is not specified, the existing image size limit is unchanged."

AddConfigHelp "Swsusp2AllSettings <params> (requires UseSwsusp2 on)" "If specified, sets all of the settings for Software Suspend 2 at once. The parameter should be the contents of $SWSUSP_ROOT/all_settings after you have set your desired settings manually."

AddConfigHelp "SuspendDevice <device> (requires UseSwsusp2 on)" "If specified, sets the suspend device by writing to the resume2 entry in $SWSUSP_ROOT. This does not automatically set the resuming device - you will need to make sure your bootloader or initrd script does this."

AddConfigHelp "LoadSuspendModules <module name> [...] (requires UseSwsusp2 on)" "Loads the given modules before even detecting Software Suspend. This may be required when Software Suspend is compiled as modules that need to be loaded prior to suspending."
AddConfigHelp "UnloadSuspendModulesAfterResume <boolean> (requires UseSwsusp2 on)" "If yes, will unload the Software Suspend modules mentioned above after resuming."

AddShortOption "n"
AddLongOption "no-suspend"
AddOptionHelp "-n, --no-suspend (requires UseSwsusp2 on)" "Disables actually suspending the system. This is useful for testing the suspend script itself."

Swsusp2ConfigEnabler() {
    [ "$1" != "useswsusp2" ] && return 1
    BoolIsOn "$1" "$2" || return 0
    [ -n "$USING_SWSUSP2" ] && return 0
    AddConfigHandler Swsusp2ConfigOptions
    AddSuspendHook 10 EnsureSwsusp2Capable
    AddSuspendHook 99 DoSwsusp2
    USING_SWSUSP2=1
    return 0
}

Swsusp2OptionHandler() {
    # Don't parse options if we're not being used.
    [ -z "$USING_SWSUSP2" ] && return 1

    case $1 in
	-r|--reboot)
	    if [ -z "$2" ] ; then
		# Cmd-line options will always override config file
		OPT_REBOOT=1
	    else
		BoolIsOn "-r" "$2" && OPT_REBOOT=1 || OPT_REBOOT=0
	    fi
	    ;;
	-n|--no-suspend)
	    SWSUSP2_NO_SUSPEND=1
	    ;;
	*)
	    return 1
    esac
    return 0
}

Swsusp2ConfigOptions() {
    case $1 in
	reboot)
	    if [ -z "$OPT_REBOOT" ] ; then
		BoolIsOn "$1" "$2" && OPT_REBOOT=1 || OPT_REBOOT=0
	    fi
	    ;;
	enableescape)
	    if [ -z "$OPT_ESCAPE" ] ; then
		BoolIsOn "$1" "$2" && OPT_ESCAPE=1 || OPT_ESCAPE=0
	    fi
	    ;;
	defaultconsolelevel)
	    if [ -z "$OPT_CONSOLELEVEL" ] ; then
		BoolIsOn "$1" "$2" && OPT_CONSOLELEVEL=1 || OPT_CONSOLELEVEL=0
	    fi
	    ;;
	imagesizelimit)
	    SWSUSP_IMAGE_SIZE_LIMIT=$2
	    ;;
	swsusp2allsettings)
	    SWSUSP_ALL_SETTINGS=$2
	    ;;
	suspenddevice)
	    SWSUSP_RESUME2=$2
	    ;;
	loadsuspendmodules)
	    AddSuspendHook 05 Swsusp2LoadModules
	    shift
	    SWSUSP_LOAD_MODULES=$@
	    ;;
	unloadsuspendmodulesafterresume)
	    BoolIsOn "$1" "$2" || return 0
	    AddResumeHook 05 Swsusp2UnloadModules
	    ;;
	*)
	    return 1
    esac
    if [ -z "$SWSUSP2_HOOKED" ] ; then
	AddSuspendHook 98 Swsusp2ConfigSet
	SWSUSP2_HOOKED=1
    fi
    return 0
}

Swsusp2ConfigSet() {
    # In earlier versions, /proc/swsusp/reboot was only available when
    # compiled with debugging. Unfortunately the interface version didn't
    # change when this was made available always :(
    [ -n "$OPT_REBOOT" ] && [ -f "$SWSUSP_ROOT/reboot" ] && \
	echo $OPT_REBOOT > $SWSUSP_ROOT/reboot

    if [ "x$SWSUSP_IMAGE_SIZE_LIMIT" = "xnocache" ] ; then
	local field val units result
	local total=0 cached=0 buffers=0 free=0
	while read field val units ; do
	    [ "x$field" = "xMemTotal:" ] && total=$val
	    [ "x$field" = "xMemFree:" ] && free=$val
	    [ "x$field" = "xBuffers:" ] && buffers=$val
	    [ "x$field" = "xCached:" ] && cached=$val
	done < /proc/meminfo
	result=$((($total-$cached-$buffers-$free+10240)/1024))
	vecho 2 "Setting image size limit to $result."
	echo $result > $SWSUSP_ROOT/image_size_limit
    else
	[ -n "$SWSUSP_IMAGE_SIZE_LIMIT" ] && echo $SWSUSP_IMAGE_SIZE_LIMIT > $SWSUSP_ROOT/image_size_limit
    fi

    [ -n "$OPT_ESCAPE" ] && echo $OPT_ESCAPE > $SWSUSP_ROOT/enable_escape
    [ -n "$OPT_CONSOLELEVEL" ] && echo $OPT_CONSOLELEVEL > $SWSUSP_ROOT/default_console_level
    [ -n "$SWSUSP_ALL_SETTINGS" ] && echo $SWSUSP_ALL_SETTINGS > $SWSUSP_ROOT/all_settings
    [ -n "$SWSUSP_RESUME2" ] && echo $SWSUSP_RESUME2 > $SWSUSP_ROOT/resume2
    return 0
}

SwsuspIsAtLeastVersion() {
    ver=`awk 'BEGIN{FS="[^0-9]"}{print($1*0x1000000)+($2*0x10000)+($3*0x100)+$4}' $SWSUSP_ROOT/version`
    [ $ver -ge $1 ] && return 0
    return 1
}

DoSwsusp2() {
    local error
    if [ -z "$SWSUSP2_NO_SUSPEND" ] ; then
	vecho 1 "$EXE: Activating suspend ..."
	error=`DoSuspend` && SUSPEND_SUCCESS=1 || SUSPEND_SUCCESS=0
	PrintErrors $error
    else
	vecho 1 "$EXE: Not actually suspending (--no-suspend given)"
    fi
    return 0
}

# DoSuspend: activates the suspend and echo's the error code to be processed by
# PrintErrors. We can't just return it, because error codes may be > 255
DoSuspend() {
    # Since 2.0.0.103 (= 0x02000067) we need to chvt manually.
    if SwsuspIsAtLeastVersion $((0x02000067)) ; then
	# Wish this and xhacks weren't doubling up on work.  This will co-exist
	# with XHacksSuspend because we need to support both old, new and other
	# versions of suspend that do/don't chvt. This code simulates what the
	# old swsusp did.
	which fgconsole > /dev/null 2>&1 && SWSUSP_ORIGINAL_VT=`fgconsole` || SWSUSP_ORIGINAL_VT=1
	chvt 63
    fi

    echo > $SWSUSP_ROOT/activate
    read REPLY < $SWSUSP_ROOT/last_result
    echo $REPLY

    [ -n "$SWSUSP_ORIGINAL_VT" ] && chvt $SWSUSP_ORIGINAL_VT

    return 0
}

# PrintAnErrorString <bit value>: prints a string corresponding to the relevant
# bit in an error code. These match up with the SUSPEND_* values in
# include/linux/suspend-debug.h
PrintAnErrorString() {
    case "$1" in
	0) echo "Suspend was aborted."
	;;
	1) echo "Suspend was aborted by user (see dmesg if unexpected)."
	;;
	2) echo "No swapspace was available. Try swapon?"
	;;
	3) echo "Not enough swapspace available. Free some memory?"
	;;
	4) echo "Freezing processes failed. Wacky driver problems :( (see dmesg)"
	;;
	5) echo "Internal error - an unexpected memory allocation occured. Driver problems? (see dmesg)"
	;;
	6) echo "Image has been kept as requested."
	;;
	7) echo "Suspend would have eaten memory. Yumm...."
	;;
	8) echo "Unable to free enough memory."
	;;
	*) echo "Unknown error! (see dmesg?)"
	;;
    esac
    return 0
}

# PrintErrors <last_result value>: prints the list of errors associated with a
# given result code
PrintErrors() {
    local code bit_num

    code="$1"
    [ "$code" -eq 0 ] && return 0

    echo "$EXE: Suspend was not completed because:"

    # A special case for "suspend aborted" and "suspend aborted by user"
    # because it'd look silly to have both.
    if [ $(($code&3)) -ne 0 ] ; then
	echo -n " - " && PrintAnErrorString 1 # aborted by user
	return 0
    fi

    bit_num=0
    while [ "$code" -ne 0 ] ; do
	[ "$((code&1))" -eq 1 ] && echo -n " - " && PrintAnErrorString "$bit_num"

	bit_num=$(($bit_num+1))
	code=$(($code>>1))
    done
    return 0
}

# GetInterfaceVersion: returns the interface version of the swsusp
# implementation in the kernel. This returns 0 if there is no swsusp in the
# kernel (note, this is interpreted as "true" in shell-speak)
GetInterfaceVersion() {
    [ -d "$SWSUSP_ROOT" ] || return 0
    [ -f "$SWSUSP_ROOT/interface_version" ] || return 0
    read REPLY < $SWSUSP_ROOT/interface_version
    return $REPLY
}

# EnsureSwsusp2Capable: makes sure we have a swsusp-capable kernel. Stops the
# script with an error message if we don't. Also ensure's we have root -
# (even though the actual suspend might not need it, everything else will)
EnsureSwsusp2Capable() {
    # Test for *any* recent swsusp support
    local ver
    GetInterfaceVersion
    ver=$?
    if [ "$ver" -eq 0 ] ; then
	cat <<EOT
Your kernel does not have any recent Software Suspend 2 support compiled in.
Please follow the HOWTO linked from http://softwaresuspend.berlios.de/ for
instructions on how to compile Software Suspend into your kernel.
EOT
	return 2
    fi

    # Check the interface version matches. Warn if it doesn't.
    if [ $ver -lt "$SWSUSP_INTERFACE_VERSION_MIN" -o $ver -gt "$SWSUSP_INTERFACE_VERSION_MAX" ] ; then
	cat <<EOT
WARNING: The swsusp2 scriptlet was written for a different swsusp2 interface
	 version from the one in your running kernel. This scriptlet was
	 written for version between $SWSUSP_INTERFACE_VERSION_MIN and $SWSUSP_INTERFACE_VERSION_MIN where as the version running
	 in your kernel is $ver. Things may not work as expected, but proceeding
	 anyway ...

EOT
    fi

    # If we have the resume2 proc entry, we can do some further tests
    # Otherwise, bail gracefully
    [ -f $SWSUSP_ROOT/resume2 ] || return 0

    # If we're going to set resume2, we needed care about this.
    [ -n "$SWSUSP_RESUME2" ] && return 0

    # See if we have been given a resume2 line
    read REPLY < $SWSUSP_ROOT/resume2
    if [ -z "$REPLY" ] ; then
	cat <<EOT
You haven't specified a resume2= parameter on your kernel command line

Your GRUB or LILO config should have something like resume2=swap:/dev/hdaX
where /dev/hdaX is your swap partition. You will then need to either reboot
after doing so or set it manually (this time only) using:
    echo swap:/dev/hdaX > $SWSUSP_ROOT/resume2
EOT
	return 2
    fi
    return 0
}

Swsusp2LoadModules() {
    local i
    local ret
    ret=0
    for i in $SWSUSP_LOAD_MODULES ; do
	vecho 2 -n "Loading suspend module $i ... "
	if modprobe $i > /dev/null 2>&1 ; then
	    vecho 2
	else
	    vecho 2 "failed."
	    ret=1
	    # Don't abort immediately, because we might be using force.
	    # So we may as well load all the modules.
	fi
    done
    return $ret
}

Swsusp2UnloadModules() {
    for i in $SWSUSP_LOAD_MODULES ; do
	vecho 2 "Unloading suspend module $i ... "
	modprobe -r `FindModuleDeps $i` > /dev/null 2>&1
    done
    return 0
}

# $Id$
