# -*- sh -*-
# vim:ft=sh:ts=8:sw=4:noet

AddConfigHandler VirtualboxOptions
AddConfigHelp "SuspendVirtualbox <boolean>" "This will run \"VBoxManage controlvm <VM> savestate\" for each running VM and restore state on resume."

VirtualboxSavestate() {

    SHUTDOWN_USERS=""
    for i in /tmp/.vbox-*-ipc; do
	SHUTDOWN_USERS="$SHUTDOWN_USERS $(echo $i|cut -d'-' -f2)"
    done
    
    VIRTUALBOX_STOPPED=""
	
    for user in $SHUTDOWN_USERS; do
	if [ -d /tmp/.vbox-$user-ipc ]; then
	    export VBOX_IPC_SOCKETID="$user"
	    VMS=`VBoxManage --nologo list runningvms 2>/dev/null`
	    if [ $? -eq 0 -a -n "$VMS" ]; then
		VMS=`echo "$VMS" | sed -e 's/^".*".*{\(.*\)}/\1/'`
		vecho 1 "Saving state of remaining VMs from user $user"
		for vm in $VMS; do
		    VBoxManage --nologo controlvm $vm savestate
		    VIRTUALBOX_STOPPED="$VIRTUALBOX_STOPPED $user:$vm"
		done
	    fi
	fi
    done
    
    sleep 2.0


    # Failure is not USUALLY fatal, but storing VM state saves reasonable
    # amount of memory. I say "USUALLY" as I'm not sure if it is virtualbox
    # that causes some suspend-related bugs.
    return 0
}

VirtualboxRestorestate() {
    local vmtag
    local user
    local vm

    for vmtag in $VIRTUALBOX_STOPPED; do
	user=$(echo $vmtag | cut -d : -f 1)
	vm=$(echo $vmtag | cut -d : -f 2)
	vecho 1 "Restoring vm $vm for user $user"
	su "$user" -c "VBoxManage -nologo startvm $vm"
    done
    unset VIRTUALBOX_STOPPED
    
    return 0
}

VirtualboxOptions() {
    case $1 in
	suspendvirtualbox)
    	    if BoolIsOn "$1" "$2" && [ -z "$VIRTUALBOX_HOOKED" ] ; then
		AddSuspendHook 20 VirtualboxSavestate
		AddResumeHook 20 VirtualboxRestorestate
		VIRTUALBOX_HOOKED=1
		VIRTUALBOX_STOPPED=""
	    fi
	    return 0
	    ;;
    esac
    return 1
}

