<!doctype linuxdoc system><!--*-sgml-*- -->

<article>
<title>Software Suspend HOWTO
<author>Florent Chabaud, Nigel Cunningham, Bernard Blackham
<date>$LastChangedDate$
<!-- $Id$ -->
<abstract>
This HOWTO documents how to suspend linux kernels to disk using the software
suspend (swsusp) kernel patch and various scripts. The source SGML file for
this HOWTO is available <url url="HOWTO.sgml" name="here">. Please
make sure all corrections are based upon this and sent to <url
URL="mailto:b-swfaq@blackham.com.au" name="Bernard">.
</abstract>

<toc>
<!-- Change log
Moved into subversion ...
v0.95 Changed all occurences of /usr/local/sbin/suspend to /usr/local/sbin/hibernate
v0.94 Note to read the FAQ as well.
v0.93 Added a note about enabling experimental kernel options (tuxo at gmx net)
v0.92 The rc4 additions/changes to the /proc interface
v0.91 Documenting the /proc interface and the hotkeys - Bernard
v0.9 Lots of changes from Nigel
v0.2  Adaptation to the beta17 version
v0.01 First version based on the FAQ page
-->
<sect> Introduction  

<sect1> What is software suspend?

<p>Software suspend is the ability to take a snapshot of the state of a
computer's memory and save it to disk, and restore that image later.
This allows you to fully power down a computer at an arbitrary point in
time and not need to reload programs and reopen documents on power-up.
In modern laptops, suspension is not done by the BIOS. They use ACPI and
ask the operating system to do most of the job. If you can't satisfy
yourself with standby mode (suspension to RAM) because you leave your
computer in suspension mode for too long (or because you're not using a
2.5 or later kernel and therefore lack suspend-to-RAM support), then you
have to suspend on disk.

<sect1> Copyright (skip this if you're in a hurry)
<p>This document is an update by Nigel Cunningham of the original howto which
was Copyright (c) 2002 by Florent Chabaud. It is currently maintained by
Bernard Blackham. You may freely copy and distribute (sell or give away) this
document in any format. Send any corrections and comments to the document
maintainer. You may create a derivative work and distribute it provided that
you:

<enum>
	<item> If it's not a translation: Email a copy of your derivative work
	 to the author(s) and maintainer (could be the same person).
	<item>License the derivative work in the spirit of this license or use
	  GPL.  Include a copyright notice and at least a pointer to the 
	  license used.
	<item>Give due credit to previous authors and major contributors.
</enum>

<sect1> Why was this document written?
<p>
Software suspend has a long story, but for a long time it was considered
as alpha. This is mainly due to the fact that suspension has to deal
with a lot of aspects in kernel. It is therefore difficult to follow the
kernel development (for instance transition from 2.2 to 2.4 was not
straightforward). The 2.4 and 2.6 patches are now considered stable. If you
have a single-processor machine with Pentium like CPU and ide disks, it is very
likely that swsusp will perform correctly. However, installing, configuring and
using software suspension is not straightforward, since it involves recompiling
the kernel and setting some boot parameters.  Software Suspend's website is
hosted by Sourceforge. You can visit the mailing list, download scripts and
updated patches at
<url url="http://developer.berlios.de/project/showfiles.php?group_id=1412">.

<p>You may want to peruse the <url url="http://softwaresuspend.berlios.de/FAQ" name="FAQ"> also.


<sect> Overview
<sect1> Kernel support
<sect2> Kernel 2.2.X
<p> Software suspend was first developped by Gabor Kuti and he used to maintain a page
<url url="http://falcon.sch.bme.hu/~seasons/linux/swsusp.html"> for his patch.
A patch is available against 2.2.20 kernel named v7c. Since this patch is no
longer maintained, this document will not provide much information on this
version.

<sect2> Kernel 2.4.X <p> Unfortunately, software suspension isn't part of
kernel 2.4.X and should therefore be added using one of the patches provided on
the download pages.  The latest patches are distributed as a tarball of
patches, which must be applied togther. This is most easily done with the
<tt>apply</tt> script inside the tarball.

<sect2> Kernel 2.6.X
<p>An implementation of Software Suspend is directly included since 2.5.18 in
the main development kernel tree. Nigel Cunningham has ported the excellent 2.4
implementation of software suspend to 2.6, and with this patch (available from
the download page), most of this HOWTO remains the same.

<sect1> Requirements
<p> Software suspension on a 2.4 kernel base needs a uni-processor machine
with a CPU featuring pse or pse36 feature (type cat /proc/cpuinfo and
check the flags line for pse or pse36). SMP support is nearly there although
needs a little more testing. Your hardware disks should be IDE (swsusp with
SCSI might be supported - nobody has confirmed or denied this recently).

<sect1> Compiling the kernel
<p> Compiling a kernel is not that hard (see the
<url url="http://www.tldp.org/HOWTO/Kernel-HOWTO.html" name="Kernel-HOWTO">) but
be sure to save your running kernel as something like /boot/vmlinuz.old
and add an entry in your lilo.conf file to be able to boot on this one.

<p> You need to choose the kernel source tree you want to use as basis. The
latest list of supported kernels is on the
<url url="http://softwaresuspend.berlios.de/" name="home page">.
You will need to download the tarball specific to your kernel version.

<p> 
Before applying any patch, you should compile the original kernel and set all
configuration options so that your computer works correctly. Save the
configuration in /usr/src/myconfig or something like that. The installation
instructions for a kernel, including lilo setup, can be found on
<url url="http://www.kernel.org">.

<sect1> Patching the kernel
<p> Once you have succeeded in compiling your kernel and installing it apply
the software suspend patches against your source tree. This is most easily done
using the apply script.

<verb>
cd /usr/src/linux (the root directory of your tree)
/path/to/software-suspend-2.1-for-2.6.9/apply
</verb>

<p>Do likewise for any options patches you want (having already applied the
main patch).

<p>If the kernel versions match, then no rejects or offsets should occur.
Otherwise, the apply script will offer to back out the changes. If your kernel
is not the vanilla one from kernel.org, you will have to apply these patches
manually and edit some of the rejected hunks.

<p>Load your previously saved configuration settings and make menuconfig
(or equivalent) again. Make sure that you have selected
<tt>Prompt for development and/or incomplete code/drivers</tt> under the
<tt>Code Maturity</tt> menu. Then enter the <tt>General Setup</tt> section, and
enable <tt>Power Management</tt>. Enter <tt>Software Suspend 2 support</tt> and
select <tt>Software Suspend 2</tt>, the <tt>Swap Writer</tt> image writer, the
<tt>LZF image compression</tt> page transformer, and the <tt>Text mode console
support</tt> user interface.  (Plus the extra suspend options if you want
them). You should find the following somewhere in the generated .config file.

<verb>
CONFIG_SOFTWARE_SUSPEND2=y
CONFIG_SOFTWARE_SUSPEND2_CORE=y
CONFIG_SOFTWARE_SUSPEND2_WRITER=y
CONFIG_SOFTWARE_SUSPEND_SWAPWRITER=y
CONFIG_SOFTWARE_SUSPEND_LZF_COMPRESSION=y
CONFIG_SOFTWARE_SUSPEND_TEXT_MODE=y
</verb>

You can also enable CONFIG_SOFTWARE_SUSPEND_DEFAULT_RESUME2 to point to your
default swap partition to avoid the need for a <tt>resume2=</tt> option on your
kernel command line.

<sect2> Initrd/initramfs's with Software Suspend 2
<p>Using an initrd with Software Suspend 2 is possible. You can either compile
Software Suspend 2 as modules or into the kernel, but you <bf>MUST</bf> edit
your linuxrc (or init) script to contain the line
<quote>
echo > /proc/software_suspend/do_resume
</quote>
<bf>BEFORE</bf> the script mounts your filesystem. If you do not, you will most likely suffer from filesystem corruption. You have been warned.
<p>See the <ref id="modular" name="Modular Software Suspend"> section for more information.

<p>You can now recompile your kernel with Software Suspend...

<sect1> Installing the new kernel
<p> You must have a swap partition on your disk. If you are using
LZF compression (highly recommended!), then you swap partition should
be about as large as your RAM (this is a rough estimation: it depends on the
number of applications you suspend and their memory consumption and how much
swap is normally used).  It has to be formatted by mkswap and used as a swap
area through /etc/fstab configuration file. You don't need a partition
specifically set aside for suspending.

<p> You must set the resume kernel option to the swap partition you want to
use for suspension. If your partition is, for instance, the third
primary one on first ide disk (/dev/hda3) you have to append
"resume2=swap:/dev/hda3" as a kernel parameter in your lilo.conf file.

<bf>IMPORTANT</bf>: make this entry the default entry in lilo.conf file.

<p>Otherwise, it is likely that you will reboot a non suspendable kernel on
a resume image which may lead to unpredictable results, including
severely damaging your filesystem. It may be useful to have another boot
option with kernel parameters "resume2=swap:/dev/hda3 noresume2" instead. This
will allow you to skip resuming and boot normally. Once again, it is
also advisable to keep an original version of the kernel in your boot
options.

<p>When you're happy with your file don't forget to run lilo and reboot the
suspendable kernel. It should boot and run the same way as your original
kernel. The only difference you should see immediately is that the boot
messages (dmesg | less) should contain a note that Software Suspend has
started (eg, "<tt>Software Suspend 2.1.5.15: Suspending enabled.</tt>").

<sect> Testing software suspend
<sect1> Installing the suspend script
<p> The best way to use swsusp is to use the hibernate script. This script
should be available on same site as the Software Suspend patch. Download it to
<tt>/tmp</tt> and type (replace 0.99 with the version you have downloaded):
<verb>
# cd /tmp
# tar xzvf hibernate-script-0.99.tar.gz
# cd hibernate-script-0.99
# ./install.sh
# 
</verb>
This will install the script, a default configuration file, and some man pages.
You may wish to edit <tt>/etc/hibernate/hibernate.conf</tt> to taste, depending
on how much of your hardware suspends correctly, and how many little features
you'd like.

<p>If you are using a RPM-based system, RPMs are available from the same
website.

<p>If you are using a Debian system, you may point your apt sources at
<tt>deb http://cp.yi.org/apt/hibernate ./</tt> and <tt>apt-get install hibernate</tt>.

<p>Check that the directory of <tt>hibernate</tt> is in your PATH variable
before going further.

<p> If you want users to be able to suspend, use <tt>visudo</tt> and add the
following lines to your /etc/sudoers file, changing the
<tt>/usr/local/sbin/hibernate</tt> to the path it was installed
(<tt>/usr/sbin/hibernate</tt> in the Debian & RPM packages)

<verb>
Host_Alias LOCALHOST=localhost,&lt;your hostname&gt;
ALL LOCALHOST=NOPASSWD: /usr/local/sbin/hibernate *
</verb>

See <em>man sudoers(5)</em> for more information. Users will then be able to do
<tt>sudo /usr/local/sbin/hibernate</tt>.

<sect1> Suspending in text mode
<p> For testing swsusp, you should begin by testing text only suspension.
Switch to a console by <tt>Ctrl-Alt F1</tt>, login as root. Under Red Hat,
Fedora or Mandrake, stop the X server by typing <tt>init 3</tt>. Debian users
will need to stop the xdm, gdm or kdm service by running <tt>/etc/init.d/xdm
stop</tt> (substituting xdm with your display manager). Users of other
distributions should do something similar.

<p> Now try <tt>hibernate</tt>. The suspension should take place ending with
machine halting. Power on the computer and it should recover your session. If
not see the troubleshooting section.

<sect1> Suspending with X running
<p> You can now recover your graphical session (by typing <tt>init 5</tt> for
Red Hat/Mandrake users, <tt>/etc/init.d/xdm start</tt> or similar for Debian
users). Log in under X. Try <tt>sudo /usr/local/sbin/hibernate</tt> and see if
suspension works correctly.

<sect> Tweaking

<sect1> Suspend script configuration
<p> The hibernate.conf file has several options that may help you to get swsusp
to work correctly on your specific hardware. Most of them are fairly
self-explanatory. Some often used ones are mentioned below. Running
<tt>hibernate -h</tt> will give you the full list of options and help.

<sect2> SwitchToTextMode
<p> On some hardware, the graphic chipset isn't properly restored by BIOS upon
resume and the state memorized by the resumed kernel becomes inconsistent with
that of the hardware. In this case, it may help to switch to a text console
before suspending and switch back to X only after resume.

<sect2> UseDummyXServer
<p>This option may also help if you experience strange things such as 3D not
working upon resume. It launches a fake xserver that should cause proper
initialization of the chipset.

<sect2> Services (RestartServices/StopServices/StartServices)
<p> It is wise to stop before suspension all services that could be resumed in
a different environment. This includes usb, pcmcia and also network services.
If your suspension is aborted because a task cannot be stopped by swsusp, and
this task corresponds to a service, you can tell the hibernate script to stop
and start these services.

<sect2> Modules (UnloadModules/UnloadAllModules/LoadModules)
<p> In the same spirit it is wise to unload before suspension all modules that
are unused. You can also force the insertion of specific modules upon resume
but usually the kernel knows upon resume the modules it needs to reload.

<sect2> Unmounting Filesystems (Unmount)
<p> Suspending while network filesystems or removable devices are mounted may
lead to unpredictible results. You can specify the mount points that must be
unused before suspension. If these can not be unmounted successfully, the
suspend script will abort unless the <tt>--force</tt> and/or <tt>--kill</tt>
option is used.  The <tt>--force</tt> option will simply ignore those mount
points. The <tt>--kill</tt> option will try to kill the processes that use
these mountpoints.

<sect2> Network interfaces (DownInterfaces/UpInterfaces)
<p> In the same spirit you can specify the network interfaces that must be shut
down before suspension. Upon resume, you can ask the suspend script to set some
interfaces up. You can also use the keyword <bf>auto</bf> to let the network
interfaces be restarted in reverse order (the default).

<sect2>Check for incompatible programs (IncompatiblePrograms)

<p> Some programs may be incompatible with swsusp because, for instance,
they directly access some hardware that ignores power management events.
You may ask suspend script to abort suspending if specified processes
are running.

<sect2> Save clock on suspend (SaveClock)
<p> It is a feature that the resumed kernel recovers its entire memory
image, including the system date which therefore appears incorrect. The
suspend script calls hwclock on resume to reset the date according to
the CMOS clock. You can ask the script to also save the system date to
CMOS just before suspending. Most of the time this is useless and will
lead your clock becoming increasingly wrong.

<sect1>Enabling debugging and tuning the system (the /proc interface)

<p>Software Suspend includes a /proc/software_suspend/ interface which allows
you to tune & configure software suspend according to your needs.  The settings
you apply here can also be read & written through a bit vector in
/proc/software_suspend/all_settings. This interface is handy for storing your
settings. Eg, you could add the line <tt>Swsusp2AllSettings N N N ...</tt> to
your /etc/hibernate/hibernate.conf (where <tt>N N N ...</tt> is taken directly
from /proc/software_suspend/all_settings). Alternately, you might do:

<verb>
cat /proc/software_suspend/all_settings > /etc/swsusp.conf
</verb>
And then add to the bottom of your /etc/rc.d/rc.sysinit (or equivalent):
<verb>
cat /etc/swsusp.conf > /proc/software_suspend/all_settings
</verb>

<sect2>/proc entry descriptions
<p>The entries within /proc/software_suspend/ are:

<descrip>
<tag><tt>all_settings</tt></tag> This replaces the old <tt>/proc/sys/kernels/swsusp</tt> - all the settings can be saved or restored at once by reading or writing the contents of this entry. Some of the data may be binary, so writing and restoring this data from a file is advised.
<tag><tt>async_io_limit</tt></tag> Maximum number of asynchronous I/O transactions
at once.
<tag><tt>debug_info</tt></tag> (Requires debug enabled) Debug information that should be included with any debugging reports.
<tag><tt>debug_sections</tt></tag> Which sections to show when viewing debug info.
Only available if debugging is compiled in (see include/linux/suspend-debug.h
in the kernel source for what each bit controls).
<tag><tt>default_console_level</tt></tag> What to use as an initial console log
level. (see <ref id="debugging-info" name="Obtaining debugging information"> below)
<tag><tt>disable_lzf_compression</tt></tag> Disables LZF compression if it was
compiled into the kernel (LZF compression is on by default when compiled in).
<tag><tt>do_suspend</tt></tag> Echo anything into this to start a suspend.
<tag><tt>do_resume</tt></tag> Echo anything into this to start resuming.
<tag><tt>enable_escape</tt></tag> Enables the possibility of aborting a suspend
by pressing the Escape key during suspend. (Note: some people consider this a
security breach if, for example, you activate a suspend, walk away and a
malicious person aborts the suspend).
<tag><tt>expected_lzf_compression</tt></tag> A guesstimate of the compression
achieved by the LZF compressor, in order to suspend when there is less swap
available than memory to be written.
<tag><tt>headerlocations</tt></tag> Having made a swapfile and turned it on,
this file will tell you what to place on your kernel command line (eg something
along the lines of <tt>resume2=swap:/dev/hda3:0x560@1024</tt>)
<tag><tt>image_size_limit</tt></tag> The maximum amount of memory swsusp will
save in the image (in megabytes).
<tag><tt>interface_version</tt></tag> A read only integer indicating the version
of the proc interface. Incremented with any change in the /proc interface.
<tag><tt>last_result</tt></tag> Bit flags indicating the result of the last cycle.
<itemize>
<item>0x1: on if the last suspend was unsuccessful. The following bits will only be on if this bit is true.
<item>0x2: suspend aborted at user's request.
<item>0x4: suspend aborted because there was no swap space enabled.
<item>0x8: suspend aborted because there was insufficient swap available.
<item>0x10: suspend aborted because all processes could not be frozen (dmesg will show which processes couldn't be frozen).
</itemize>

<tag><tt>log_everything</tt></tag> Set to log output that's not normally logged.
<tag><tt>no_output</tt></tag> Set to disable all output from swsusp during the cycle.
<tag><tt>nopageset2</tt></tag> (&lt;=2.0 only) Set to save all data in one
pageset. Implies a maximum image size of half the amount of low memory.
<tag><tt>pause_between_steps</tt></tag> Pause between the steps of the process
(useful for debugging).
<tag><tt>powerdown_method</tt></tag> Use your machine's ACPI implementation to
put the machine to sleep in one of 3 ways. Entering 3 into here will make the
machine enter S3 (suspend-to-RAM) after writing the image to disk. This allows
for a faster resume under normal circumstances, but no losses if your battery
should run out or for any other reason suspend-to-RAM should not wake up.
Entering 4 will use the machine's S4 state - this may result in a faster
resume, as many of the usual BIOS checks may be skipped. Entering 5 will
powerdown the machine as per usual.
<tag><tt>reboot</tt></tag> Set to reboot instead of powering off at the end of
saving the image.
<tag><tt>resume2</tt></tag> Allows you to set what would be on the kernel
command line as resume2= (saves a reboot if you forget). This tells the kernel
where to write the suspend image. You will still need to add it to your
bootloader (LILO or GRUB) in order to resume from the image!
<tag><tt>slow</tt></tag> Slows down the suspend process (for debugging).
<tag><tt>swapfilename</tt></tag> Set the name of the swapfile to be automatically
enabled and disabled before and after suspending. See
<ref id="swapfiles" name="Using a swapfile"> for more information.
<tag><tt>version</tt></tag> Read only. The version of the software suspend
patch you are using.
</descrip>

<sect2>Obtaining debugging information<label id="debugging-info">

<p>To get debugging information, you first need to have compiled Software
Suspend with the 'Compile in debugging output' option enabled. You will
probably also want to compile in SysRq support (in the 'Kernel Hacking'
section). Having done this, during a suspend cycle, you can press
the 0-9 keys to change the console loglevel. As you do so, swsusp varies
the amount of output it produces. Level 0 is the normal 'nice' display.
Level 1 enables a little more detail. Levels 3+ turn off the nice
display and give more detailed information.

<p>You can toggle whether swsusp pauses between each step of the process by
pressing the Pause or Break (useful if you have KDB enabled) keys. There are
also proc entries to set initial values for these settings. You may not want to
view all the information swsusp prints. In this case, you can set the
debug_sections parameter to control what portions of output are printed (see
include/linux/suspend-debug.h in the kernel source for what each bit controls).

<sect1>Software suspend hotkeys

<p>When a suspend is in progress there are a number of keys that can be used to
toggle various settings.

<itemize>
<item> <bf>Esc</bf> - if the <tt>enable_escape</tt> entry is set to 1, pressing 
Escape will abort a suspend and restore the machine back to the previous state.
Perfect for those "Oh, but I just forgot to ..." situations.

<item> <bf>R</bf> - toggles rebooting at the end of suspending (same as the
<tt>reboot</tt> /proc entry).

<item> <bf>P</bf> (Requires debug enabled) - toggles pausing between major steps when log level > 1.

<item> <bf>S</bf> (Requires debug enabled) - toggles pausing between minor steps.

<item> <bf>`</bf> (Requires debug enabled) - toggles slowing down the suspend process.

<item> <bf>Space</bf> - continue when paused.

<item> <bf>L</bf> - toggles logging all messages to syslog (same as the
<tt>log_everything</tt> /proc entry). This requires that debugging be enabled (compiled in).

<item> <bf>0</bf>-<bf>7</bf> - sets the console log level during suspend and
resume. This requires that debugging be enabled (compiled in).
</itemize>

<sect1>Avoiding data loss

<p>While much care has gone into Software Suspend to ensure reliability and
safety of your data, there are some unusual scenarios which may lead to
filesystem corruption and data loss. With a modern journalled filesystem (eg,
ext3, reiserfs, xfs, jfs) a failed resume should not cause filesystem
corruption, as this is the equivalent of simply losing power which should be
dealt with gracefully.

<p>Other more dangerous situations are described below, with ways to workaround
and avoid them:

<label id="dataloss1"><sect2>Booting non-Software Suspend aware kernels

<p><bf>Problem</bf>: Booting a second kernel that does
not recognise the suspended image in your swap partition. Or, attempting to
resume with the same kernel, but failing to put a <tt>resume2=</tt> parameter
in your bootloader, then putting one in and resuming without removing the image
first.
<p>This is very dangerous as there is no warning. For example, you have two
kernels, Kernel A and Kernel B. Kernel A has Software Suspend support, and
Kernel B does not.
<p>The danger comes when suspending with Kernel A, you then decide to boot
Kernel B, that does not recognize the swap image. It ignores the "bad" swap
partition and runs without it as if nothing happened (except it may run low on
memory).
<p>The problem to the suspended Kernel A is that since Kernel B mounted the
filesystem r/w, it no longer matches the suspended kernel and will be corrupted
on resume. Thus, severe damage to the filesystem will result once the disk is
written to by the resumed kernel. 
<p>This problem has bitten unsuspecting users when, for example, a new kernel
is released for their distribution and automatically installed, or if you boot
a live CD (eg, Knoppix) and try to mount filesystems from there.

<p><bf>Solution</bf>: Should this scenario occur, either the suspended kernel
must be prevented from resuming. This can be accomplished by an mkswap of the
swap partition from Kernel B, or booting Kernel A with noresume2.  To make sure
this always happens, below is a snippet from SuSE's bootscripts (courtesy of
Stefan Seyfried) that you can put into an init script that is started early on
boot (before swapspace is enabled). Another alternative is to modify your
bootloader upon suspending to enforce you to boot the same kernel.  The
hibernate script has configuration options for doing this in both GRUB and
LILO. 

<quote><verb>
#!/bin/sh

get_swap_id() {
	local line;
	fdisk -l | while read line; do
		case "$line" in
			/*Linux\ [sS]wap*) echo "${line%% *}"
		esac
	done
}

check_swap_sig () {
	local part="$(get_swap_id)"
	local where what type rest p c
	while read  where what type rest ; do
		test "$type" = "swap" || continue
		c=continue
		for p in $part ; do
			test "$p" = "$where" && c=true
		done
		$c
		case "$(dd if=$where bs=1 count=6 skip=4086 2>/dev/null)" in
		S1SUSP|S2SUSP|pmdisk|[zZ]*) mkswap $where
		esac
	done < /etc/fstab
}

check_swap_sig
</verb></quote>

<sect2>Windows touches your FAT partitions whilst Linux is suspended
<p><bf>Problem</bf>: Similar to the scenario above, if you have mounted FAT drives
or partitions when suspending and you then boot into Windows, as soon as you
boot back into Linux you will probably end up corrupting your FAT drives.

<p><bf>Solution</bf>: Unmount your FAT drives before suspending. If you are using
the Hibernate Script, you can use the following line in your hibernate.conf:
<quote><verb>
UnmountFSTypes vfat fat msdos
</verb></quote>

<sect2>An initrd mounts your filesystem before resuming
<p><bf>Problem</bf>: An incorrectly setup initrd can corrupt your filesystem if it
tries to mount it before resuming.
<p>If your filesystem is touched in any way before resuming, your data will risk
serious corruption. This even includes mounting the filesystem in read-only mode
as many journalling filesystems (ext3, reiserfs, xfs) will replay the journal.

<p><bf>Solution</bf>: Ensure your initrd is setup correctly - attempting to
resume should be the first thing it tries to do after mounting /proc. If you
are using an initrd, enable the "Warn if possibility of filesystem corruption"
in the Software Suspend 2 kernel configuration. This will throw a BIG FAT
WARNING if you try to resume after a filesystem has been mounted read/write. It
won't catch all cases, but will probably get the most common ones.
<p>You may find this will throw spurious BIG FAT WARNINGs at your initrd being
mounted read-write (which is safe in itself, as it is not linked to the hard
disk). To avoid the warning here, you should mount your initrd as read-only
whilst trying to resume, by putting the two mount lines below into your linuxrc
script:
<quote><verb>
mount -n -o remount,ro /
echo > /proc/software_suspend/do_resume
mount -n -o remount,rw /
</verb></quote>

<sect>Troubleshooting<label id="trouble">

<sect1>It panics!

<p>D'oh. If you can capture the panic somehow (either over a serial console, or
digital camera if need be), and send it to the list, somebody might hopefully
be able to do something about it. Before you send it to the list, try
suspending from single user mode (described below) and see if the same thing
happens.

<p>Panics captured on 2.4 must be run through the <tt>ksymoops</tt> program
before any useful information can be obtained from them.

<sect1>It hangs!

<p>The most common symptom of a non-functioning Software Suspend is a hang
either during suspending or resuming. Hangs while resuming have two sources:
<enum>
<item>Foul ups by Nigel in the kernel code
<item>Driver issues
</enum>

<p>Type 1 issues will generally affect areas other than the point where you see
"<tt>Copying original kernel back</tt>". There are known issues with Software
Suspend itself (type 1 issues) in the 2.1.5 series which should be fixed in
2.1.7.

<p>Type 2 issues are more common, and affect particular hardware (and therefore
some computers/configurations, but not others). There are usually workarounds
for these issues, and the workarounds generally involve building functionality
as modules and stopping related userpace daemons and unloading the modules prior
to suspend, and reloading/restarting afterwards. Particularly common here are
issues with USB, DRI/DRM, FireWire, cpufreq, sound card and network drivers. In
the case of DRI/DRM, you can't simply disable it prior to resuming, so people
(unfortunately) have to choose between 3D performance and the ability to
suspend (unless you're willing to stop X prior to suspending and restart it
afterwards). As driver writers improve their support for suspending and
resuming, it is expected that these issues will ultimately go away.

<p>Finding which driver is causing suspend to hang is sometimes less than
obvious.  In these cases, we recommend starting with a minimal environment
(init S) and seeing if you can suspend from there, or failing that with
init=/bin/sh. If you have success, add more and more components of your normal
configuration until you find something that breaks suspending. If you can't
even suspend from init S, it may be that you've compiled the driver that's
causing problems into the kernel. In this case, look at your kernel
configuration and seek to compile as modules as much as possible. Then try with
a minimal configuration again.

<sect1>Suspending in a minimalist environment
<p>To eliminate problems with drivers, people will often recommend to suspend
from single user mode or use init=/bin/sh.

<sect2>Single user mode (init S)
<p>Linux distributions where many services are not enabled, and ideally, many
modules are not enabled.  It can be entered by adding the letter "<tt>S</tt>"
to the kernel command line when you boot. Unfortunately some distributions will
still load many modules in this runlevel, so if suspend still fails here, you
might need to try using init=/bin/sh.

<sect2>init=/bin/sh
<p>In this mode, absolutely nothing else is done afer loading the kernel. It
requires a bit of manual intervention to get things going into a usable state,
documented below, but should help in isolating bad drivers causing Software
Suspend to fail.

<itemize>
<item>To enter this mode, as you boot your machine you need to catch your
bootloader (eg, LILO or GRUB) before it boots your kernel. Edit the kernel
command-line to add the text "<tt>init=/bin/sh</tt>". In LILO this can be done
by holding the Ctrl key down to bring up the menu, selecting your kernel with
the arrow keys, then typing " init=/bin/sh" and press Enter. In GRUB, you can
do this by highlighting your kernel in the menu, press E to edit, highlight the
line that begins "kernel ...", press E to edit that, and type " init=/bin/sh"
on the end, press Enter to save, and press B to boot.
<item>You should be greeted with a screen of the kernel booting and a prompt
that looks a little like <verb>sh-3.00# </verb>
<item>From here, enter the following commands:
<itemize>
<item><tt># mount -o remount,rw /</tt>
<item><tt># mount -t proc proc proc</tt>
<item><tt># swapon -a</tt>
</itemize>
You may need to start devfsd or udev too:
<itemize>
<item><tt># /etc/init.d/devfsd start</tt>
</itemize>
And now try running the hibernate script to see if it succeeds. If so, you can
blame a module and now the process begins to load modules one by one until
hibernation breaks.
<item>To cleanly reboot from this point, you will want to do the following:
<itemize>
<item><tt># mount -o remount,ro /</tt>
<item><tt># sync</tt>
<item><tt># reboot</tt>
</itemize>
</itemize>

<sect1>Asking for help
<p>People on the softwaresuspend-help and softwaresuspend-devel
<url url="###BASE###lists" name="mailing lists"> are generally pretty helpful, but
they'll be better able to help you if you can provide more information. In
particular, it will help if you provide information regaring what make/model of
computer you have, what modules you have loaded while trying to suspend, and a
copy of your kernel configuration.  Most of details can be quickly and easily
gathered using the 1.03 or later hibernate script with the --bug-report option.

<p>If you are sending a kernel panic from a 2.4 kernel, be sure to run the
output through ksymoops and send the result. Otherwise the panic is of
very little use to anybody.

<sect>How it works
<p> For the more curious users, briefly listed here are the steps of the kernel part
of the suspend process. This may also help in tracking why it doesn't suspend.

<enum>
<item> Stop all processes. If some processes can't be stopped, abort. 
<item> Eat memory. At this stage we check if we have enough memory to save the
image and meet your specifications for maximum image size. If necessary, we
unfreeze the processes, eat memory until we think we have enough and then try
again from step 1.
<item> Suspend drivers. This accounts for the screen briefly going blank on
some computers.
<item> Prepare a directory of pages and save it along with the image. This
is done in two parts. First, all of the pages we know aren't needed for
suspend (ie, not buffer & page caches) are saved, being very careful not to have
a lasting impact on the image we're making. Then, an atomic copy is made
of the remaining pages (kernel & process space) using the memory just
saved and any other free RAM. This copy is then saved. Finally, we save
the page directory for the latter set of pages separately and also store
the page directory's location in the swap header. We can then (if your
computer supports it) power down.
</enum>

Resuming is essentially the reverse of this process. The pagedir is
loaded, as is the copy (being careful not to use RAM we're about to
overwrite). Then we copy the old kernel back and restore registers. We
are now running with the original kernel image. Finally, we load the
first set of pages we saved, clean up and exit.

<sect>Other configurations
<sect1>Software Suspend compiled as modules<label id="modular">

<sect2>Advantages
<p>
<itemize>
<item> Compiling suspend as modules lets you have a smaller base kernel. The
code will not be taking up memory when it's not being used.
<item> Certain upgrades of suspend code become possible without rebooting,
by simply recompiling and reloading the modules. Even so, some code is still
built into the kernel, and changes to these parts will require a reboot.
<item> It allows for loading other modules from the initrd that might help
overcome power management issues.
<item> It allows for encryption support to be included (crypto loop)
<item> Support for storage devices can be made modular as well (Debian's default
kernels do this).
</itemize>

<sect2>Disadvantages
<p>
<itemize>
<item> Set up and install is a little more complicated.
<item> If you do not correctly set up your initrd, you may cause filesystem
corruption. (The initrd must not mount filesystems before attempting to
resume).
</itemize>

<sect2>Configuring your kernel

<p>In configuring suspend itself, you can compile as much or as little as
modules as you like. The core code can be built as a module, or just the
plugins.

<p>In addition to this, you will need to compile initrd support so that
suspend modules can be loaded from the initrd and suspend activated
before any filesystems are mounted. Your initrd will require a /sys directory
in which a sysfs filesystem will be briefly mounted (if not already mounted
by your linuxrc script).

<p>At resume time, suspend needs to do its work in the <tt>linuxrc</tt> script,
before any filesystems are mounted. This implies that the modules for suspend
must be put in the initrd and loaded before the initrd does any mounting of
filesystems (the modules can be inserted, but the mount commands must come
later). Note: in Debian kernels, a script in /scripts/ is executed too late.
See <url url="###WIKI_URL###DistroAndHardwareSetup/DebianInitrd" name="DebianInitrd on the wiki">.

<sect2>Sample linuxrc
<p>
<verb>
#!/bin/sh
/bin/mount none /proc -t proc
/bin/insmod -q /lib/suspend_core.ko
/bin/insmod -q /lib/suspend_lzf.ko
/bin/insmod -q /lib/suspend_block_io.ko
/bin/insmod -q /lib/suspend_swap.ko
/bin/insmod -q /lib/suspend_text.ko
echo > /proc/software_suspend/do_resume
/bin/umount /proc
</verb>

<p>Notes:
<itemize>
<item> You need to mount /proc so you can access the do_resume file.
<item> Any support for storage devices should be installed before the writer
to avoid 'Unable to parse resume device' messages.
<item> Normal filesystems should be mounted afterwards.
</itemize>

<sect2>Checklist

<p>
<enum>
<item> Apply the new patches to your kernel.
<item> Configure (don't forget initrd support and don't forget to check that suspend support is selected. Changes to the Kconfig file mean it will be
treated as a new option).
<item> make bzImage modules modules_install
<item> Install the bzImage (make sure you can boot an old kernel, just in
case) and run lilo if needed.
<item> Mount or create your initrd and copy the suspend modules to the
initrd. Also ensure that there is a /sys directory inside your initrd.
<item> Edit your initrd's linuxrc to load the modules and then call echo >
/proc/software_suspend/do_suspend BEFORE any mounting of filesystems
(apart from proc) is done.
<item> Unmount your initrd.
<item> Reboot to init S.
<item> Check dmesg or /var/log/messages to confirm that your initrd ran
fine, that you see the modules installed and that they report all being
well with the world.
<item> Try to suspend (and resume!)
</enum>

<p><bf>WHEN YOU BUILD A NEW KERNEL, DON'T FORGET TO UPDATE THE MODULES IN THE
INITRD!!</bf>

<sect2>Problems
<p>See the <url url="###BASE###FAQ-6#modular" name="Modules FAQ"> for solutions to
common problems.

<sect2>Distribution specific tips
<p>See the <url url="###BASE###FAQ-6#ss6.4" name="Modules FAQ"> for some
distribution-specific tips.

<sect1>Using a swapfile<label id="swapfiles">
<p><bf>NOTE:</bf> Currently (correct as of 2.1.5.10), your filesystem must have
a 4k-blocksize.  ext3 and reiserfs do. XFS, by default, does not. If you don't
know, follow steps 1 and 2 below and see what value follows the @ sign in
<tt>headerlocations</tt>. If it is not 4096, then wait until a Software Suspend
version is released that does handle non-4K blocks (or stay tuned
here).
<enum>
<item>Create and activate your swap file:
<itemize>
<item><tt># dd if=/dev/zero of=/path/to/swapfile bs=1M count=&lt;size in MB&gt;</tt>
<item><tt># mkswap /path/to/swapfile</tt>
<item><tt># swapon /path/to/swapfile</tt>
<item>Make sure you know what device your swapfile is on (eg, /dev/hda4). If you're not
sure, run <tt>mount</tt> and find the longest mountpoint that is a prefix to
the path of the swapfile (eg, it might be /usr/local, /usr or just /). Read the
corresponding device to this mountpoint.
</itemize>
<item>Find out your header locations:
<itemize>
<item><verb># cat /proc/software_suspend/headerlocations
For swapfile `/path/to/swapfile               `, use resume2=swap:/dev/&lt;partition name&gt;:0x2da2b4@4096.
</verb>
<item>For example, if I know the swapfile is on /dev/hda1, then my "resume2=" line becomes <tt>resume2=swap:/dev/hda1:0x2da2b4@4096</tt>
</itemize>
<item>Enter your resume2= line:
<itemize>
<item>On the kernel command line either in lilo.conf, or GRUB's menu.lst, put the full <tt>resume2=...</tt> parameter.
<ITEM>If you use the hibernate script, in hibernate.conf put <tt>SuspendDevice swap:/dev/hda1:0x2da2b4@4096</tt>
<item>If you use a custom suspend script, enter <tt>echo swap:/dev/hda1:0x2da2b4@4096 > /proc/software_suspend/resume2</tt> somewhere before suspending.
</itemize>
Doing one of the last two changes above is not required, but if you don't you
will have to reboot your machine before being able to suspend to the swapfile.
<item>Get your swap partition automatically enabled and disabled for suspending:
<itemize>
<item>By entering the name of your swapfile into
/proc/software_suspend/swapfile before suspending, Software Suspend will
automatically enable and disable the swapfile for you. This is not required,
but merely a convenience.
</itemize>
</enum>

<sect2>Superfluous details
<p>Specifying the resume2= device simply tells Software Suspend where to write
and find the header that indicates the machine is suspended and where to find
the rest of the image. The image itself is written to any available swapspace
whether it be swapfile or swap partition. The actual order of swap devices that
data is written to turns out to essentially be the order in which swap
partitions are enabled. Hence it's entirely plausible if you have a normal swap
partition (or file), and one turned on only for suspending, that the entire
image is contained in the first swap partition, but the header alone is in the
second.

<sect1>Swap on LVM/dm-crypt
<p>This requires Software Suspend 2.1.4.2 or later.

<enum>
<item>You will need to use an initrd or initramfs support, so your kernel must
have support for this. Since you're using one anyway, you might like to compile
<ref id="modular" name="suspend as modules"> while you're at it :&gt;
<item>Configure your LVM/encrypted swap/whatever like you normally would.
<item>Modify your initrd/initramfs as follows:
    <itemize>
    <item>install a statically linked version of dmsetup
    <item>install any suspend/dm modules needed for your configuration
    <item>ensure that /dev, /dev/mapper, /proc and /sys exist on that filesystem
    <item>create a link from /dev/mapper/&lt;partition name&gt; to /dev/dm-0:
    <quote><verb>ln -s /dev/mapper/&lt;partition name&gt; /dev/dm-0</verb></quote>
    <item>use dmsetup table &lt;partition name&gt; to store the configuration for your partition in a file on the initrd|ramfs.
    <item>in your linuxrc/init:
        <itemize>
        <item>mount /proc
        <item>load modules as required
        <item>use dmsetup create dm-0 &lt;path to config-file&gt; to set up access to the LVM partition
        <item>echo &gt; /proc/software_suspend/do_resume
        <item>do any other actions required (mount rootfs if initramfs...)
        <item>umount /proc if initrd.
        </itemize>
    </itemize>
</enum>

<sect1>Using an initrd/initramfs but Software Suspend compiled in

<p>If you are using an initrd, you <bf>MUST</bf> edit the linuxrc script to
attempt to resume before filesystems are mounted. Do this by inserting the line:
<verb>
echo > /proc/software_suspend/do_resume
</verb>
somewhere after mount /proc but before mounting filesystems in your linuxrc
script.

<p>If you are using an initramfs, you will need to do the same thing to your
/sbin/init script, else you will never be able to resume.

<p>See the <url url="###BASE###FAQ-6#ss6.4" name="Modules FAQ"> for some
distribution-specific tips.

</article>
