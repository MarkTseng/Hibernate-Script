diff -ruNpax '*.orig' -x '*.rej' linux-2.6.10-1.760_FC3-patched/fs/read_write.c linux-2.6.10-1.760_FC3-post/fs/read_write.c
--- linux-2.6.10-1.760_FC3-patched/fs/read_write.c	2005-02-03 13:49:10.000000000 -0800
+++ linux-2.6.10-1.760_FC3-post/fs/read_write.c	2005-02-03 13:51:05.000000000 -0800
@@ -314,7 +314,6 @@ asmlinkage ssize_t sys_write(unsigned in
 
 	return ret;
 }
-EXPORT_SYMBOL(sys_write);
 
 EXPORT_SYMBOL_GPL(sys_write);
 
diff -ruNpax '*.orig' -x '*.rej' linux-2.6.10-1.760_FC3-patched/include/asm-i386/kmap_types.h linux-2.6.10-1.760_FC3-post/include/asm-i386/kmap_types.h
--- linux-2.6.10-1.760_FC3-patched/include/asm-i386/kmap_types.h	2005-02-03 13:49:10.000000000 -0800
+++ linux-2.6.10-1.760_FC3-post/include/asm-i386/kmap_types.h	2005-02-03 16:17:59.845306503 -0800
@@ -24,7 +24,9 @@ D(10)	KM_IRQ1,
 D(11)	KM_SOFTIRQ0,
 D(12)	KM_SOFTIRQ1,
 D(13)	KM_KDB,
-D(14)	KM_TYPE_NR
+D(14)	KM_CRASHDUMP,
+D(15)	KM_UNUSED,
+D(16)	KM_TYPE_NR
 };
 
 #undef D
diff -ruNpax '*.orig' -x '*.rej' linux-2.6.10-1.760_FC3-patched/include/linux/sched.h linux-2.6.10-1.760_FC3-post/include/linux/sched.h
--- linux-2.6.10-1.760_FC3-patched/include/linux/sched.h	2005-02-03 13:49:10.000000000 -0800
+++ linux-2.6.10-1.760_FC3-post/include/linux/sched.h	2005-02-03 13:51:16.000000000 -0800
@@ -741,6 +741,7 @@ do { if (atomic_dec_and_test(&(tsk)->usa
 #define PF_BORROWED_MM	0x00400000	/* I am a kthread doing use_mm */
 #define PF_SYNCTHREAD	0x00800000	/* this thread can start activity during the 
 					   early part of freezing processes */
+#define PF_RELOCEXEC	0x01000000	/* relocate shared libraries */
 
 #ifdef CONFIG_SMP
 extern int set_cpus_allowed(task_t *p, cpumask_t new_mask);
diff -ruNpax '*.orig' -x '*.rej' linux-2.6.10-1.760_FC3-patched/include/linux/sysctl.h linux-2.6.10-1.760_FC3-post/include/linux/sysctl.h
--- linux-2.6.10-1.760_FC3-patched/include/linux/sysctl.h	2005-02-03 13:49:09.000000000 -0800
+++ linux-2.6.10-1.760_FC3-post/include/linux/sysctl.h	2005-02-03 13:51:24.000000000 -0800
@@ -135,6 +135,7 @@ enum
 	KERN_HZ_TIMER=65,	/* int: hz timer on or off */
 	KERN_UNKNOWN_NMI_PANIC=66, /* int: unknown nmi panic flag */
 	KERN_KDB=67,		/* int: kdb on/off */
+	KERN_SETUID_DUMPABLE=68, /* int: behaviour of dumps for setuid core */
 };
 
 
diff -ruNpax '*.orig' -x '*.rej' linux-2.6.10-1.760_FC3-patched/kernel/exit.c linux-2.6.10-1.760_FC3-post/kernel/exit.c
--- linux-2.6.10-1.760_FC3-patched/kernel/exit.c	2005-02-03 13:49:10.000000000 -0800
+++ linux-2.6.10-1.760_FC3-post/kernel/exit.c	2005-02-03 13:50:47.000000000 -0800
@@ -821,6 +821,13 @@ fastcall NORET_TYPE void do_exit(long co
 	group_dead = atomic_dec_and_test(&tsk->signal->live);
 	if (group_dead)
 		acct_process(code);
+	if (current->tux_info) {
+#ifdef CONFIG_TUX_DEBUG
+		printk("Possibly unexpected TUX-thread exit(%ld) at %p?\n",
+			code, __builtin_return_address(0));
+#endif
+		current->tux_exit();
+	}
 
 #ifdef CONFIG_MKI
        if (unlikely(tsk->mki_task_info))
diff -ruNpax '*.orig' -x '*.rej' linux-2.6.10-1.760_FC3-patched/kernel/sched.c linux-2.6.10-1.760_FC3-post/kernel/sched.c
--- linux-2.6.10-1.760_FC3-patched/kernel/sched.c	2005-02-03 13:49:11.000000000 -0800
+++ linux-2.6.10-1.760_FC3-post/kernel/sched.c	2005-02-03 13:51:16.000000000 -0800
@@ -3630,7 +3630,6 @@ static inline struct task_struct *younge
 	if (p->sibling.next==&p->parent->children) return NULL;
 	return list_entry(p->sibling.next,struct task_struct,sibling);
 }
-EXPORT_SYMBOL_GPL(show_state);
 
 void show_task(task_t * p)
 {
diff -ruNpax '*.orig' -x '*.rej' linux-2.6.10-1.760_FC3-patched/kernel/timer.c linux-2.6.10-1.760_FC3-post/kernel/timer.c
--- linux-2.6.10-1.760_FC3-patched/kernel/timer.c	2005-02-03 13:49:10.000000000 -0800
+++ linux-2.6.10-1.760_FC3-post/kernel/timer.c	2005-02-03 16:18:07.585441772 -0800
@@ -33,6 +33,8 @@
 #include <linux/cpu.h>
 #include <linux/syscalls.h>
 #include <linux/suspend.h>
+#include <linux/delay.h>
+#include <linux/diskdump.h>
 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
@@ -469,7 +471,7 @@ repeat:
 			set_running_timer(base, timer);
 			smp_wmb();
 			timer->base = NULL;
-			spin_unlock_irq(&base->lock);
+			spin_unlock_irqrestore(&base->lock, flags);
 			if (unlikely(test_suspend_state(SUSPEND_TIMER_FREEZER_ON) && (!timer->no_freeze))) {
 				int shown = 0, i, copy_start = 0;
 				for (i = 0; i < FN_CACHE_SIZE; i++)
