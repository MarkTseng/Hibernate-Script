AddConfigHandler ModulesOptions
AddConfigHelp "UnloadModules <module name> [...]" "Names of modules to unload prior to suspending."
AddConfigHelp "LoadModules <module name> [...]" "Names of modules to load after resumimg."
AddConfigHelp "UnloadAllModules <boolean>" "Try to remove all modules loaded prior to suspending."
AddConfigHelp "AutoLoadModules <boolean>" "Try to load default modules after resuming (distribution specific)."

ModulesUnload() {
    [ -z "$MOD_UNLOAD" ] && return 0
    local mod
    for mod in $MOD_UNLOAD ; do 
	vecho 1 "Unloading module $mod..."
	modprobe -r $mod | $LOGPIPE
    done
    return 0
}

ModulesLoad() {
    [ -z "$MOD_LOAD" ] && return 0
    local mod
    for mod in $MOD_LOAD ; do 
	vecho 1 "Loading module $mod..."
	modprobe $mod | $LOGPIPE
    done
    return 0
}

ModulesUnloadAllOnce() {
    local module
    for module in `awk '($3==0){print $1}' /proc/modules` ;do
	vecho 1 "Unloading module $module..."
	modprobe -r $module | $LOGPIPE
    done
}

ModulesUnloadAll() {
    [ x"$MODULES_UNLOADALL" = "x1" ] || return 1

    local modbefore
    local modafter
    local mod_retry_count

    # read from /proc/modules which modules are loaded
    modbefore="`awk '($3==0){print $1}' /proc/modules`"
    ModulesUnloadAllOnce
    modafter="`awk '($3==0){print $1}' /proc/modules`"

    # check which are still loaded and retry until nothing changes
    mod_retry_count=0
    while [ "$modafter" != "$modules" ] ; do
	usleep 200000
	ModulesUnloadAllOnce
	modafter=`awk '($3==0){print $1}' /proc/modules`
	[ "$mod_retry_count" -gt 5 ] && break
	mod_retry_count=$(($mod_retry_count+1))
    done

    vecho 1 "Some modules failed to unload: `cat /proc/modules` "
    return 0
}

ModulesAutoLoad() {
    [ x"$MODULES_AUTOLOAD" = "x1" ] || return 0
    # This is distribution specific    
    # XXX - add code for other distros
    
    case "$DISTRIBUTION" in
	gentoo)
	    # for gentoo users
	    . /sbin/functions.sh
	    # taken from gentoo's /etc/init.d/modules
	    if [ -f /etc/modules.autoload -a ! -L /etc/modules.autoload ] ; then
		modules_autoload_file= /etc/modules.autoload
	    else
		local KV="$(uname -r)"
		local KV_MAJOR="`KV_major "${KV}"`"
		local KV_MINOR="`KV_minor "${KV}"`"

		# New support for /etc/modules.autoload/kernel-$KV
		if [ "$(get_KV)" -ge "$(KV_to_int '2.5.48')" ] && \
		[ -f /etc/modules.autoload.d/kernel-"${KV_MAJOR}.${KV_MINOR}" ]
		then
		    modules_autoload_file="/etc/modules.autoload.d/kernel-${KV_MAJOR}.${KV_MINOR}"
		elif [ ! -f /etc/modules.autoload.d/kernel-"${KV_MAJOR}.${KV_MINOR}" ]
		then
		    ewarn "Missing /etc/modules.autoload.d/kernel-${KV_MAJOR}.${KV_MINOR}"
		    modules_autoload_file="/etc/modules.autoload.d/kernel-2.4"
		else
		    modules_autoload_file="/etc/modules.autoload.d/kernel-2.4"
		fi
	    fi

	    local MOD
	    local args
	    # Loop over every line in $modules_autoload_file.
	    vecho 1 "Loading modules listed $modules_autoload_file" 
	    while : ; do
		read MOD args
		[ $? -ne 0 ] && [ -z "$MOD" ] && break
		case "${MOD}" in
		    \#*|"") continue ;;
		esac
		vecho 1 "Loading $MOD" 
		modprobe ${MOD} ${args} | $LOGPIPE
	    done < $modules_autoload_file
	    ;;
	*)
	    vecho 1 "Warning: ModulesAutoLoad is not supported in this distribution."
	    ;;
    esac
    return 0
}


ModulesOptions() {
    case $1 in
	unloadmodules)
	    [ -z "$MOD_UNLOAD" ] && AddSuspendHook 90 ModulesUnload
	    shift
	    MOD_UNLOAD="$MOD_UNLOAD $@"
	    ;;
	loadmodules)
	    [ -z "$MOD_LOAD" ] && AddResumeHook 90 ModulesLoad
	    shift
	    MOD_LOAD="$MOD_LOAD $@"
	    ;;
	unloadallmodules)
	    if BoolIsOn "$1" "$2" ; then
		MODULES_UNLOADALL=1
		AddSuspendHook 91 ModulesUnloadAll
	    fi
	    ;;
	autoloadmodules)
	    if BoolIsOn "$1" "$2" ; then
		MODULES_AUTOLOAD=1
		AddResumeHook 91 ModulesAutoLoad
	    fi
	    ;;
	*)
	    return 1
    esac
    return 0
}

# $Id$
# vim:ft=sh:ts=8:sw=4:noet
